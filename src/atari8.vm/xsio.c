
/***************************************************************************

    XSIO.C

    - Atari serial port emulation

    Copyright (C) 1986-2018 by Darek Mihocka. All Rights Reserved.
    Branch Always Software. http://www.emulators.com/

    11/30/2008  darekm      open source release
    09/27/2000  darekm      last update

***************************************************************************/

#include "atari800.h"

#ifdef XFORMER

#define DEBUGCOM 0

//
// SIO stuff
//

/* SIO return codes */
#define SIO_OK      0x01
#define SIO_TIMEOUT 0x8A
#define SIO_NAK     0x8B
#define SIO_DEVDONE 0x90

typedef struct
{
    WORD mode;
    WORD  h;
    WORD fWP;
    WORD wSectorMac;
    WORD ofs;
//    char *pbRAMdisk;
    char path[80];
    char name[12];
    ULONG cb;   // size of file when mode == MD_FILE*
} DRIVE;

#define MAX_DRIVES 2

DRIVE rgDrives[MAX_VM][MAX_DRIVES];

#define MD_OFF  0
#define MD_SD   1
#define MD_ED   2
#define MD_DD   3            // normally, the first 3 sectors are 128 bytes long, then 768 bytes of blank, and then sector 4
#define MD_DD_OLD_ATR1 4    // early .ATR files have the first half of the first three 256 byte sectors filled
#define MD_DD_OLD_ATR2 5    // other early .ATR files sector 4 start at offset 384 w/o blank space
#define MD_QD   6
#define MD_HD   7
#define MD_RD   8
#define MD_35   9
#define MD_EXT  10
#define MD_FILE 11          // an unknown PC File mounted as an ATARI DOS File for them to see
#define MD_FILEBIN 12       // a PC file that is an ATARI binary, mounted as an ATARI DOS file and also as an auto-boot
#define MD_FILEBAS 13       // a PC file that is maybe an ATARI BASIC file, mounted in ATARI DOS and auto-booting

// !!! scary globals that don't seem to be used anymore
int wCOM;
int fXFCable;

// This code is borrowed from an old exe loader, but doesn't show the menu and let you select an exe, it auto-loads
// the first one, and doesn't alter the display list since some apps don't make their own DL but assume GR.0 is
// already set up for them.
//
// Also, there was a bug, if a very short segment was loaded, two different initializations would happen during
// the same sector JMP ($2E2) and each would DEC CRITIC, so CRITIC was $FF and interrupts were disabled and could hang 
// the app during the 2nd code portion (Ridiculous Reality).
// !!! There's still a bug where CRITIC is set wrong, I should fix it here instead of inside JMP () so that an
// ATR image can be created that will work on real hardware
//
// Since there is no source code to this program (I typed it in in hex) I should probably say a few things about it.
// Some apps (Capt. Sticky) set DOSVEC and return from ($2E0) but aren't supposed to, so I have to jmp ($a) if they do that.
// This loader only occupies $700 to $87f, it loads all sectors into $a00, which seems dangerous ($400 is the safest place)
// but some stupid games (gunfighter) seem to only work under emulation expecting an SIO hack to not use $400 for sector 
// loading, as they put data there they expect to stick around after more sectors are loaded! In other words, so many
// programs expect the binary loader to occupy $700-$87F and to load sectors in $a00, that's what I have to do as my first try.
// !!! Also, to support quad density binary files, I treat the sector number as 12 bits, even though DOS only support 10 bits.
// I borrow the bottom two bits of the file #. These files can't be easily copied to an ATR image either for this emulator
// or for real hardware (the image is too big plus this hack breaks DOS 2.0)

const BYTE Bin1[128] = {
    0x00, 0x03, 0x00, 0x07, 0x08, 0x07, 0x18, 0x60, 0xA9, 0x00, 0x8D, 0x44, 0x02, 0xA8, 0x99, 0x80,
    0x08, 0x88, 0xD0, 0xFA, 0xC8, 0x84, 0x09, 0x8C, 0x01, 0x03, 0xCE, 0x06, 0x03, 0x4c, 0x2c, 0x07,
    0x20, 0xf9, 0x07, 0x80, 0x00, 0xe6, 0x42, 0x60, 0xea, 0xea, 0xea, 0xea, 0xa9, 0x69, 0x85, 0x18,
    0xA5, 0x18, 0x8D, 0x0A, 0x03, 0xA9, 0x01, 0x8D, 0x0B, 0x03, 0xE6, 0x18, 0x20, 0x0D, 0x08, 0xB9,
    0x00, 0x0a, 0xF0, 0x47, 0x30, 0x3B, 0xA6, 0x47, 0xB9, 0x03, 0x0a, 0x95, 0x5A, 0xB9, 0x04, 0x0a,
    0x95, 0x6E, 0x8A, 0x18, 0x69, 0x91, 0xA6, 0x48, 0x9D, 0x80, 0x08, 0xA9, 0x0B, 0x85, 0x49, 0xB9,
    0x05, 0x0a, 0x38, 0xE9, 0x20, 0x9D, 0x82, 0x08, 0xC8, 0xE8, 0xC6, 0x49, 0xD0, 0xF1, 0x98, 0x38,
    0xE9, 0x0B, 0xA8, 0x8A, 0x18, 0x69, 0x09, 0x85, 0x48, 0xE6, 0x47, 0xA5, 0x47, 0xC9, 0x09, 0xF0 };

const BYTE Bin2[128] = { 
    0x0A, 0x98, 0x18, 0x69, 0x10, 0xA8, 0x0A, 0x90, 0xB6, 0xB0, 0xA5, 0xC6, 0x42, 0x85, 0x14, 0xC5,
    0x14, 0xF0, 0xFC, 0xA9, 0x31, 0xEA, 0x38, 0xE9, 0x31, 0xC5, 0x47, 0xB0, 0xF6, 0xAA, 0xea, 0xea,
    0xea, 0xB5, 0x5A, 0x8D, 0x0A, 0x03, 0xB5, 0x6E, 0x8D, 0x0B, 0x03, 0x20, 0x21, 0x08, 0xCA, 0x20,
    0xFC, 0x07, 0x85, 0x43, 0x20, 0xFC, 0x07, 0x85, 0x44, 0x25, 0x43, 0xC9, 0xFF, 0xF0, 0xF0, 0x20,
    0xFC, 0x07, 0x85, 0x45, 0x20, 0x6c, 0x08, 0xea, 0xea, 0x20, 0xFC, 0x07, 0x91, 0x43, 0xE6, 0x43,
    0xD0, 0x02, 0xE6, 0x44, 0xA5, 0x45, 0xC5, 0x43, 0xA5, 0x46, 0xE5, 0x44, 0xB0, 0xEB, 0xAD, 0xE2,
    0x02, 0x0D, 0xE3, 0x02, 0xF0, 0xc9, 0x86, 0x19, 0xC6, 0x42, 0x20, 0x20, 0x07, 0xA6, 0x19, 0xA0,
    0x00, 0x8C, 0xE2, 0x02, 0x8C, 0xE3, 0x02, 0xF0, 0xB6, 0x6C, 0xE2, 0x02, 0xE0, 0x7D, 0xD0, 0x4A };

const BYTE Bin3[128] = {
    0xAD, 0x0A, 0x03, 0x0D, 0x0B, 0x03, 0xD0, 0x19, 0xC6, 0x42, 0x4C, 0x63, 0x08, 0xA9, 0x31, 0x8D,
    0x00, 0x03, 0xA9, 0x52, 0x8D, 0x02, 0x03, 0xA9, 0x0a, 0x8D, 0x05, 0x03, 0xA9, 0x80, 0x8D, 0x08,
    0x03, 0xA9, 0x40, 0x8D, 0x03, 0x03, 0x20, 0x59, 0xE4, 0x30, 0xF6, 0xE6, 0x42, 0xAD, 0x7D, 0x0a,
    0x29, 0x0f, 0x8D, 0x0B, 0x03, 0xAD, 0x7E, 0x0a, 0x8D, 0x0A, 0x03, 0xea, 0xea, 0xea, 0xAD, 0x7F,
    0x0a, 0x29, 0x7F, 0x8D, 0xFD, 0x07, 0xA0, 0x00, 0xA2, 0x00, 0xBD, 0x00, 0x0a, 0xE8, 0x60, 0xAD,
    0x25, 0xE4, 0x48, 0xAD, 0x24, 0xE4, 0x48, 0x60, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea,
    0xea, 0xea, 0xea, 0x20, 0x69, 0x08, 0x6c, 0x0a, 0x00, 0x6c, 0xe0, 0x02, 0x20, 0xfc, 0x07, 0x85,
    0x46, 0x80, 0x00, 0x60, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea };

// The $d600 version of the loader, residing safely in ROM where it can't possibly interfere with 
// loading. Unfortunately, something needing this loader cannot be easily copied into an ATR image
// and used on real hardware, but it couldn't anyway. It loads sectors into $400 because the second
// class of apps that needs this loader assumes $700-$87f is fair game but knows to stay away from $400

const BYTE BinA1[128] = {
    0x00, 0x03, 0x00, 0xd6, 0x08, 0xd6, 0x18, 0x60, 0xA9, 0x00, 0x8D, 0x44, 0x02, 0xA8, 0x99, 0x80,
    0x08, 0x88, 0xD0, 0xFA, 0xC8, 0x84, 0x09, 0x8C, 0x01, 0x03, 0xCE, 0x06, 0x03, 0x4c, 0x2c, 0xD6,
    0x20, 0xf9, 0xD6, 0x80, 0x00, 0xe6, 0x42, 0x60, 0xea, 0xea, 0xea, 0xea, 0xa9, 0x69, 0x85, 0x18,
    0xA5, 0x18, 0x8D, 0x0A, 0x03, 0xA9, 0x01, 0x8D, 0x0B, 0x03, 0xE6, 0x18, 0x20, 0x0D, 0xD7, 0xB9,
    0x00, 0x04, 0xF0, 0x47, 0x30, 0x3B, 0xA6, 0x47, 0xB9, 0x03, 0x04, 0x95, 0x5A, 0xB9, 0x04, 0x04,
    0x95, 0x6E, 0x8A, 0x18, 0x69, 0x91, 0xA6, 0x48, 0x9D, 0x80, 0x08, 0xA9, 0x0B, 0x85, 0x49, 0xB9,
    0x05, 0x04, 0x38, 0xE9, 0x20, 0x9D, 0x82, 0x08, 0xC8, 0xE8, 0xC6, 0x49, 0xD0, 0xF1, 0x98, 0x38,
    0xE9, 0x0B, 0xA8, 0x8A, 0x18, 0x69, 0x09, 0x85, 0x48, 0xE6, 0x47, 0xA5, 0x47, 0xC9, 0x09, 0xF0 };

const BYTE BinA2[128] = {
    0x0A, 0x98, 0x18, 0x69, 0x10, 0xA8, 0x0A, 0x90, 0xB6, 0xB0, 0xA5, 0xC6, 0x42, 0x85, 0x14, 0xC5,
    0x14, 0xF0, 0xFC, 0xA9, 0x31, 0xEA, 0x38, 0xE9, 0x31, 0xC5, 0x47, 0xB0, 0xF6, 0xAA, 0xea, 0xea,
    0xea, 0xB5, 0x5A, 0x8D, 0x0A, 0x03, 0xB5, 0x6E, 0x8D, 0x0B, 0x03, 0x20, 0x21, 0xD7, 0xCA, 0x20,
    0xFC, 0xD6, 0x85, 0x43, 0x20, 0xFC, 0xD6, 0x85, 0x44, 0x25, 0x43, 0xC9, 0xFF, 0xF0, 0xF0, 0x20,
    0xFC, 0xD6, 0x85, 0x45, 0x20, 0x6c, 0xd7, 0xea, 0xea, 0x20, 0xFC, 0xd6, 0x91, 0x43, 0xE6, 0x43,
    0xD0, 0x02, 0xE6, 0x44, 0xA5, 0x45, 0xC5, 0x43, 0xA5, 0x46, 0xE5, 0x44, 0xB0, 0xEB, 0xAD, 0xE2,
    0x02, 0x0D, 0xE3, 0x02, 0xF0, 0xc9, 0x86, 0x19, 0xC6, 0x42, 0x20, 0x20, 0xd6, 0xA6, 0x19, 0xA0,
    0x00, 0x8C, 0xE2, 0x02, 0x8C, 0xE3, 0x02, 0xF0, 0xB6, 0x6C, 0xE2, 0x02, 0xE0, 0x7D, 0xD0, 0x4A };

const BYTE BinA3[128] = {
    0xAD, 0x0A, 0x03, 0x0D, 0x0B, 0x03, 0xD0, 0x19, 0xC6, 0x42, 0x4C, 0x63, 0xd7, 0xA9, 0x31, 0x8D,
    0x00, 0x03, 0xA9, 0x52, 0x8D, 0x02, 0x03, 0xA9, 0x04, 0x8D, 0x05, 0x03, 0xA9, 0x80, 0x8D, 0x08,
    0x03, 0xA9, 0x40, 0x8D, 0x03, 0x03, 0x20, 0x59, 0xE4, 0x30, 0xF6, 0xE6, 0x42, 0xAD, 0x7D, 0x04,
    0x29, 0x0f, 0x8D, 0x0B, 0x03, 0xAD, 0x7E, 0x04, 0x8D, 0x0A, 0x03, 0xea, 0xea, 0xea, 0xAD, 0x7F,
    0x04, 0x29, 0x7F, 0x8D, 0xfd, 0xd6, 0xA0, 0x00, 0xA2, 0x00, 0xBD, 0x00, 0x04, 0xE8, 0x60, 0xAD,
    0x25, 0xE4, 0x48, 0xAD, 0x24, 0xE4, 0x48, 0x60, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea,
    0xea, 0xea, 0xea, 0x20, 0x69, 0xd7, 0x6c, 0x0a, 0x00, 0x6c, 0xe0, 0x02, 0x20, 0xfc, 0xd6, 0x85,
    0x46, 0x80, 0x00, 0x60, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea };

#if 0    // first version of my loader, altering DL and w/ critic bug
BYTE Bin1[128] = {
    0x00, 0x03, 0x00, 0x07, 0x08, 0x07, 0x18, 0x60, 0xA9, 0x00, 0x8D, 0x44, 0x02, 0xA8, 0x99, 0x80,
    0x08, 0x88, 0xD0, 0xFA, 0xC8, 0x84, 0x09, 0x8C, 0x01, 0x03, 0xCE, 0x06, 0x03, 0xA9, 0x58, 0x8D,
    0x30, 0x02, 0xA9, 0x08, 0x8D, 0x31, 0x02, 0xA9, 0x69, 0x85, 0x18, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
    0xA5, 0x18, 0x8D, 0x0A, 0x03, 0xA9, 0x01, 0x8D, 0x0B, 0x03, 0xE6, 0x18, 0x20, 0x0D, 0x08, 0xB9,
    0x00, 0x0A, 0xF0, 0x47, 0x30, 0x3B, 0xA6, 0x47, 0xB9, 0x03, 0x0A, 0x95, 0x5A, 0xB9, 0x04, 0x0A,
    0x95, 0x6E, 0x8A, 0x18, 0x69, 0x91, 0xA6, 0x48, 0x9D, 0x80, 0x08, 0xA9, 0x0B, 0x85, 0x49, 0xB9,
    0x05, 0x0A, 0x38, 0xE9, 0x20, 0x9D, 0x82, 0x08, 0xC8, 0xE8, 0xC6, 0x49, 0xD0, 0xF1, 0x98, 0x38,
    0xE9, 0x0B, 0xA8, 0x8A, 0x18, 0x69, 0x09, 0x85, 0x48, 0xE6, 0x47, 0xA5, 0x47, 0xC9, 0x09, 0xF0 };

BYTE Bin2[128] = {
    0x0A, 0x98, 0x18, 0x69, 0x10, 0xA8, 0x0A, 0x90, 0xB6, 0xB0, 0xA5, 0xC6, 0x42, 0x85, 0x14, 0xC5,
    0x14, 0xF0, 0xFC, 0xA9, 0x31, 0xEA, 0x38, 0xE9, 0x31, 0xC5, 0x47, 0xB0, 0xF6, 0xAA, 0xDE, 0x60,
    0x08, 0xB5, 0x5A, 0x8D, 0x0A, 0x03, 0xB5, 0x6E, 0x8D, 0x0B, 0x03, 0x20, 0x21, 0x08, 0xCA, 0x20,
    0xFC, 0x07, 0x85, 0x43, 0x20, 0xFC, 0x07, 0x85, 0x44, 0x25, 0x43, 0xC9, 0xFF, 0xF0, 0xF0, 0x20,
    0xFC, 0x07, 0x85, 0x45, 0x20, 0xFC, 0x07, 0x85, 0x46, 0x20, 0xFC, 0x07, 0x91, 0x43, 0xE6, 0x43,
    0xD0, 0x02, 0xE6, 0x44, 0xA5, 0x45, 0xC5, 0x43, 0xA5, 0x46, 0xE5, 0x44, 0xB0, 0xEB, 0xAD, 0xE2,
    0x02, 0x0D, 0xE3, 0x02, 0xF0, 0xC9, 0x86, 0x19, 0xC6, 0x42, 0x20, 0xF9, 0x07, 0xA6, 0x19, 0xA0,
    0x00, 0x8C, 0xE2, 0x02, 0x8C, 0xE3, 0x02, 0xF0, 0xB6, 0x6C, 0xE2, 0x02, 0xE0, 0x7D, 0xD0, 0x4A };

BYTE Bin3[128] = {
    0xAD, 0x0A, 0x03, 0x0D, 0x0B, 0x03, 0xD0, 0x19, 0xC6, 0x42, 0x6C, 0xE0, 0x02, 0xA9, 0x31, 0x8D,
    0x00, 0x03, 0xA9, 0x52, 0x8D, 0x02, 0x03, 0xA9, 0x0A, 0x8D, 0x05, 0x03, 0xA9, 0x80, 0x8D, 0x08,
    0x03, 0xA9, 0x40, 0x8D, 0x03, 0x03, 0x20, 0x59, 0xE4, 0x30, 0xF6, 0xE6, 0x42, 0xAD, 0x7D, 0x0A,
    0x29, 0x03, 0x8D, 0x0B, 0x03, 0xAD, 0x7E, 0x0A, 0x8D, 0x0A, 0x03, 0x8D, 0x17, 0xD0, 0xAD, 0x7F,
    0x0A, 0x29, 0x7F, 0x8D, 0xFD, 0x07, 0xA0, 0x00, 0xA2, 0x00, 0xBD, 0x00, 0x0A, 0xE8, 0x60, 0xAD,
    0x25, 0xE4, 0x48, 0xAD, 0x24, 0xE4, 0x48, 0x60, 0x70, 0x70, 0x70, 0x47, 0x6C, 0x08, 0x70, 0x70,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x41, 0x58, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x78, 0x66, 0x6F, 0x72, 0x6D, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

// This version is relocated to $480 and I load sectors into $400. Previously it used memory up to $a80 so any binary
// that used memory lower than that couldn't load. Now it only uses RAM <$600.
// However most people making binaries expect a loader to occupy $600-$a80 and don't use that, and
// actually hang with this alternate loader because they use $400-$600
// Lords.xex and Head Over Heels 1 & 3.xex need this alternate version, though, so I will auto-detect when to use it

BYTE BinA1[128] = {
    0x00, 0x03, 0x80, 0x04, 0x88, 0x04, 0x18, 0x60, 0xA9, 0x00, 0x8D, 0x44, 0x02, 0xA8, 0x99, 0x80,
    0x08, 0x88, 0xD0, 0xFA, 0xC8, 0x84, 0x09, 0x8C, 0x01, 0x03, 0xCE, 0x06, 0x03, 0x4c, 0xac, 0x04,
    0x20, 0x79, 0x05, 0x80, 0x00, 0xe6, 0x42, 0x60, 0xea, 0xea, 0xea, 0xea, 0xa9, 0x69, 0x85, 0x18,
    0xA5, 0x18, 0x8D, 0x0A, 0x03, 0xA9, 0x01, 0x8D, 0x0B, 0x03, 0xE6, 0x18, 0x20, 0x8D, 0x05, 0xB9,
    0x00, 0x04, 0xF0, 0x47, 0x30, 0x3B, 0xA6, 0x47, 0xB9, 0x03, 0x04, 0x95, 0x5A, 0xB9, 0x04, 0x04,
    0x95, 0x6E, 0x8A, 0x18, 0x69, 0x91, 0xA6, 0x48, 0x9D, 0x00, 0x06, 0xA9, 0x0B, 0x85, 0x49, 0xB9,
    0x05, 0x04, 0x38, 0xE9, 0x20, 0x9D, 0x02, 0x06, 0xC8, 0xE8, 0xC6, 0x49, 0xD0, 0xF1, 0x98, 0x38,
    0xE9, 0x0B, 0xA8, 0x8A, 0x18, 0x69, 0x09, 0x85, 0x48, 0xE6, 0x47, 0xA5, 0x47, 0xC9, 0x09, 0xF0 };

BYTE BinA2[128] = {
    0x0A, 0x98, 0x18, 0x69, 0x10, 0xA8, 0x0A, 0x90, 0xB6, 0xB0, 0xA5, 0xC6, 0x42, 0x85, 0x14, 0xC5,
    0x14, 0xF0, 0xFC, 0xA9, 0x31, 0xEA, 0x38, 0xE9, 0x31, 0xC5, 0x47, 0xB0, 0xF6, 0xAA, 0xea, 0xea,
    0xea, 0xB5, 0x5A, 0x8D, 0x0A, 0x03, 0xB5, 0x6E, 0x8D, 0x0B, 0x03, 0x20, 0xa1, 0x05, 0xCA, 0x20,
    0x7C, 0x05, 0x85, 0x43, 0x20, 0x7C, 0x05, 0x85, 0x44, 0x25, 0x43, 0xC9, 0xFF, 0xF0, 0xF0, 0x20,
    0x7C, 0x05, 0x85, 0x45, 0x20, 0xeC, 0x05, 0xea, 0xea, 0x20, 0x7C, 0x05, 0x91, 0x43, 0xE6, 0x43,
    0xD0, 0x02, 0xE6, 0x44, 0xA5, 0x45, 0xC5, 0x43, 0xA5, 0x46, 0xE5, 0x44, 0xB0, 0xEB, 0xAD, 0xE2,
    0x02, 0x0D, 0xE3, 0x02, 0xF0, 0xC9, 0x86, 0x19, 0xC6, 0x42, 0x20, 0xa0, 0x04, 0xA6, 0x19, 0xA0,
    0x00, 0x8C, 0xE2, 0x02, 0x8C, 0xE3, 0x02, 0xF0, 0xB6, 0x6C, 0xE2, 0x02, 0xE0, 0x7D, 0xD0, 0x4A };

BYTE BinA3[128] = {
    0xAD, 0x0A, 0x03, 0x0D, 0x0B, 0x03, 0xD0, 0x19, 0xC6, 0x42, 0x4C, 0xe3, 0x05, 0xA9, 0x31, 0x8D,
    0x00, 0x03, 0xA9, 0x52, 0x8D, 0x02, 0x03, 0xA9, 0x04, 0x8D, 0x05, 0x03, 0xA9, 0x80, 0x8D, 0x08,
    0x03, 0xA9, 0x40, 0x8D, 0x03, 0x03, 0x20, 0x59, 0xE4, 0x30, 0xF6, 0xE6, 0x42, 0xAD, 0x7D, 0x04,
    0x29, 0x0f, 0x8D, 0x0B, 0x03, 0xAD, 0x7E, 0x04, 0x8D, 0x0A, 0x03, 0xea, 0xea, 0xea, 0xAD, 0x7F,
    0x04, 0x29, 0x7F, 0x8D, 0x7D, 0x05, 0xA0, 0x00, 0xA2, 0x00, 0xBD, 0x00, 0x04, 0xE8, 0x60, 0xAD,
    0x25, 0xE4, 0x48, 0xAD, 0x24, 0xE4, 0x48, 0x60, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea,
    0xea, 0xea, 0xea, 0x20, 0xe9, 0x05, 0x6c, 0x0a, 0x00, 0x6c, 0xe0, 0x02, 0x20, 0x7c, 0x05, 0x85,
    0x46, 0xa9, 0xff, 0x8d, 0xe2, 0x02, 0x8D, 0xe3, 0x02, 0x6c, 0xe2, 0x02, 0x60, 0xea, 0xea, 0xea };
#endif

// DOS 2.0 boot sectors

BYTE Bas1[128] = {
    0x00, 0x03, 0x00, 0x07, 0x40, 0x15, 0x4C, 0x14, 0x07, 0x03, 0x03, 0x00, 0x7C, 0x1A, 0x01, 0x04,
    0x00, 0x7D, 0xCB, 0x07, 0xAC, 0x0E, 0x07, 0xF0, 0x36, 0xAD, 0x12, 0x07, 0x85, 0x43, 0x8D, 0x04,
    0x03, 0xAD, 0x13, 0x07, 0x85, 0x44, 0x8D, 0x05, 0x03, 0xAD, 0x10, 0x07, 0xAC, 0x0F, 0x07, 0x18,
    0xAE, 0x0E, 0x07, 0x20, 0x6C, 0x07, 0x30, 0x17, 0xAC, 0x11, 0x07, 0xB1, 0x43, 0x29, 0x03, 0x48,
    0xC8, 0x11, 0x43, 0xF0, 0x0E, 0xB1, 0x43, 0xA8, 0x20, 0x57, 0x07, 0x68, 0x4C, 0x2F, 0x07, 0xA9,
    0xC0, 0xD0, 0x01, 0x68, 0x0A, 0xA8, 0x60, 0x18, 0xA5, 0x43, 0x6D, 0x11, 0x07, 0x8D, 0x04, 0x03,
    0x85, 0x43, 0xA5, 0x44, 0x69, 0x00, 0x8D, 0x05, 0x03, 0x85, 0x44, 0x60, 0x8D, 0x0B, 0x03, 0x8C,
    0x0A, 0x03, 0xA9, 0x52, 0xA0, 0x40, 0x90, 0x04, 0xA9, 0x57, 0xA0, 0x80, 0x8D, 0x02, 0x03, 0x8C };

BYTE Bas2[128] = {
    0x03, 0x03, 0xA9, 0x31, 0xA0, 0x0F, 0x8D, 0x00, 0x03, 0x8C, 0x06, 0x03, 0xA9, 0x03, 0x8D, 0xFF,
    0x12, 0xA9, 0x00, 0xA0, 0x80, 0xCA, 0xF0, 0x04, 0xA9, 0x01, 0xA0, 0x00, 0x8D, 0x09, 0x03, 0x8C,
    0x08, 0x03, 0x20, 0x59, 0xE4, 0x10, 0x1D, 0xCE, 0xFF, 0x12, 0x30, 0x18, 0xA2, 0x40, 0xA9, 0x52,
    0xCD, 0x02, 0x03, 0xF0, 0x09, 0xA9, 0x21, 0xCD, 0x02, 0x03, 0xF0, 0x02, 0xA2, 0x80, 0x8E, 0x03,
    0x03, 0x4C, 0xA2, 0x07, 0xAE, 0x01, 0x13, 0xAD, 0x03, 0x03, 0x60, 0xAA, 0x08, 0x14, 0x0B, 0xBE,
    0x0A, 0xCB, 0x09, 0x00, 0x0B, 0xA6, 0x0B, 0x07, 0x85, 0x44, 0xAD, 0x0A, 0x07, 0x8D, 0xD6, 0x12,
    0xAD, 0x0C, 0x07, 0x85, 0x43, 0xAD, 0x0D, 0x07, 0x85, 0x44, 0xAD, 0x0A, 0x07, 0x8D, 0x0C, 0x13,
    0xA2, 0x07, 0x8E, 0x0D, 0x13, 0x0E, 0x0C, 0x13, 0xB0, 0x0D, 0xA9, 0x00, 0x9D, 0x11, 0x13, 0x9D };

BYTE Bas3[128] = {
    0x29, 0x13, 0x9D, 0x31, 0x13, 0xF0, 0x36, 0xA0, 0x05, 0xA9, 0x00, 0x91, 0x43, 0xE8, 0x8E, 0x01,
    0x03, 0xA9, 0x53, 0x8D, 0x02, 0x03, 0x20, 0x53, 0xE4, 0xA0, 0x02, 0xAD, 0xEA, 0x02, 0x29, 0x20,
    0xD0, 0x01, 0x88, 0x98, 0xAE, 0x0D, 0x13, 0x9D, 0x11, 0x13, 0xA5, 0x43, 0x9D, 0x29, 0x13, 0xA5,
    0x44, 0x9D, 0x31, 0x13, 0x20, 0x70, 0x08, 0x88, 0xF0, 0x03, 0x20, 0x70, 0x08, 0xCA, 0x10, 0xB2,
    0xAC, 0x09, 0x07, 0xA2, 0x00, 0xA9, 0x00, 0x88, 0x10, 0x01, 0x98, 0x9D, 0x19, 0x13, 0x98, 0x30,
    0x0D, 0xA5, 0x43, 0x9D, 0x39, 0x13, 0xA5, 0x44, 0x9D, 0x49, 0x13, 0x20, 0x70, 0x08, 0xE8, 0xE0,
    0x10, 0xD0, 0xE2, 0xA5, 0x43, 0x8D, 0xE7, 0x02, 0xA5, 0x44, 0x8D, 0xE8, 0x02, 0x4C, 0x7E, 0x08,
    0x18, 0xA5, 0x43, 0x69, 0x80, 0x85, 0x43, 0xA5, 0x44, 0x69, 0x00, 0x85, 0x44, 0x60, 0xA0, 0x7F };

BYTE AUTORUN[156] = {
    0xFF, 0xFF, 0x00, 0x06, 0x8D, 0x06, 0xA2, 0x00, 0xBD, 0x1A, 0x03, 0xC9, 0x45, 0xF0, 0x05, 0xE8,
    0xE8, 0xE8, 0xD0, 0xF4, 0xE8, 0x8E, 0x69, 0x06, 0xBD, 0x1A, 0x03, 0x85, 0xCD, 0xA9, 0x6B, 0x9D,
    0x1A, 0x03, 0xE8, 0xBD, 0x1A, 0x03, 0x85, 0xCE, 0xA9, 0x06, 0x9D, 0x1A, 0x03, 0xA0, 0x00, 0xA2,
    0x10, 0xB1, 0xCD, 0x99, 0x6B, 0x06, 0xC8, 0xCA, 0xD0, 0xF7, 0xA9, 0x43, 0x8D, 0x6F, 0x06, 0xA9,
    0x06, 0x8D, 0x70, 0x06, 0xA9, 0x12, 0x8D, 0x6A, 0x06, 0x60, 0xAC, 0x6A, 0x06, 0xF0, 0x09, 0xB9,
    0x7B, 0x06, 0xCE, 0x6A, 0x06, 0xA0, 0x01, 0x60, 0x8A, 0x48, 0xAE, 0x69, 0x06, 0xA5, 0xCD, 0x9D,
    0x1A, 0x03, 0xE8, 0xA5, 0xCE, 0x9D, 0x1A, 0x03, 0x68, 0xAA, 0xA9, 0x9B, 0xA0, 0x01, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x22, 0x43, 0x42, 0x41, 0x2E, 0x48, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41, 0x3A, 0x44,
    0x22, 0x4E, 0x55, 0x52, 0xFF, 0xFF, 0xE2, 0x02, 0xE3, 0x02, 0x00, 0x06 };

BYTE DOS20[4875] = {
    0xaa, 0x08, 0x14, 0x0b, 0xbe, 0x0a, 0xcb, 0x09, 0x00, 0x0b, 0xa6, 0x0b, 0x07, 0x85, 0x44, 0xad,
    0x0a, 0x07, 0x8d, 0xd6, 0x12, 0xad, 0x0c, 0x07, 0x85, 0x43, 0xad, 0x0d, 0x07, 0x85, 0x44, 0xad,
    0x0a, 0x07, 0x8d, 0x0c, 0x13, 0xa2, 0x07, 0x8e, 0x0d, 0x13, 0x0e, 0x0c, 0x13, 0xb0, 0x0d, 0xa9,
    0x00, 0x9d, 0x11, 0x13, 0x9d, 0x29, 0x13, 0x9d, 0x31, 0x13, 0xf0, 0x36, 0xa0, 0x05, 0xa9, 0x00,
    0x91, 0x43, 0xe8, 0x8e, 0x01, 0x03, 0xa9, 0x53, 0x8d, 0x02, 0x03, 0x20, 0x53, 0xe4, 0xa0, 0x02,
    0xad, 0xea, 0x02, 0x29, 0x20, 0xd0, 0x01, 0x88, 0x98, 0xae, 0x0d, 0x13, 0x9d, 0x11, 0x13, 0xa5,
    0x43, 0x9d, 0x29, 0x13, 0xa5, 0x44, 0x9d, 0x31, 0x13, 0x20, 0x70, 0x08, 0x88, 0xf0, 0x03, 0x20,
    0x70, 0x08, 0xca, 0x10, 0xb2, 0xac, 0x09, 0x07, 0xa2, 0x00, 0xa9, 0x00, 0x88, 0x10, 0x01, 0x98,
    0x9d, 0x19, 0x13, 0x98, 0x30, 0x0d, 0xa5, 0x43, 0x9d, 0x39, 0x13, 0xa5, 0x44, 0x9d, 0x49, 0x13,
    0x20, 0x70, 0x08, 0xe8, 0xe0, 0x10, 0xd0, 0xe2, 0xa5, 0x43, 0x8d, 0xe7, 0x02, 0xa5, 0x44, 0x8d,
    0xe8, 0x02, 0x4c, 0x7e, 0x08, 0x18, 0xa5, 0x43, 0x69, 0x80, 0x85, 0x43, 0xa5, 0x44, 0x69, 0x00,
    0x85, 0x44, 0x60, 0xa0, 0x7f, 0xa9, 0x00, 0x99, 0x81, 0x13, 0x88, 0xd0, 0xfa, 0xa0, 0x00, 0xb9,
    0x1a, 0x03, 0xf0, 0x0c, 0xc9, 0x44, 0xf0, 0x08, 0xc8, 0xc8, 0xc8, 0xc0, 0x1e, 0xd0, 0xf0, 0x00,
    0xa9, 0x44, 0x99, 0x1a, 0x03, 0xa9, 0xcb, 0x99, 0x1b, 0x03, 0xa9, 0x07, 0x99, 0x1c, 0x03, 0x60,
    0x20, 0x64, 0x11, 0x20, 0x9e, 0x0e, 0xbd, 0x4a, 0x03, 0x9d, 0x82, 0x13, 0x29, 0x02, 0xf0, 0x03,
    0x4c, 0xad, 0x0d, 0x20, 0x21, 0x0f, 0x08, 0xbd, 0x82, 0x13, 0xc9, 0x04, 0xf0, 0x0f, 0xc9, 0x08,
    0xf0, 0x44, 0xc9, 0x0c, 0xf0, 0x0c, 0xc9, 0x09, 0xf0, 0x17, 0x4c, 0xbf, 0x12, 0x28, 0xb0, 0x0e,
    0x90, 0x06, 0x28, 0xb0, 0x09, 0x20, 0xac, 0x0c, 0x20, 0xae, 0x09, 0x4c, 0xf0, 0x12, 0x4c, 0xbb,
    0x12, 0x28, 0xb0, 0xfa, 0xac, 0x05, 0x13, 0xb9, 0x01, 0x14, 0x29, 0x02, 0xf0, 0x15, 0x20, 0xac,
    0x0c, 0x20, 0xbf, 0x10, 0x20, 0x06, 0x11, 0x9d, 0x8e, 0x13, 0xbd, 0x8b, 0x13, 0x9d, 0x8d, 0x13,
    0x4c, 0x7c, 0x09, 0x4c, 0xb7, 0x12, 0x28, 0xb0, 0x09, 0x20, 0x53, 0x0c, 0xac, 0x05, 0x13, 0x4c,
    0x48, 0x09, 0xad, 0x02, 0x13, 0x30, 0x70, 0x8d, 0x06, 0x13, 0x20, 0x6e, 0x10, 0xad, 0x03, 0x13,
    0x8d, 0x05, 0x13, 0xad, 0x04, 0x13, 0x8d, 0x07, 0x13, 0x20, 0xbf, 0x10, 0xac, 0x05, 0x13, 0xa2,
    0x0a, 0xa9, 0x20, 0x99, 0x06, 0x14, 0xc8, 0xca, 0x10, 0xf9, 0xae, 0x01, 0x13, 0x20, 0x06, 0x11,
    0xac, 0x05, 0x13, 0x99, 0x05, 0x14, 0xbd, 0x8b, 0x13, 0x99, 0x04, 0x14, 0xa9, 0x43, 0x99, 0x01,
    0x14, 0xa9, 0x00, 0x99, 0x03, 0x14, 0x99, 0x02, 0x14, 0xa2, 0x00, 0xbd, 0x59, 0x13, 0xc9, 0x3f,
    0xf0, 0x03, 0x99, 0x06, 0x14, 0xc8, 0xe8, 0xe0, 0x0b, 0x90, 0xf0, 0xae, 0x01, 0x13, 0x20, 0x71,
    0x10, 0x20, 0x95, 0x09, 0x20, 0xe2, 0x0f, 0xa9, 0x80, 0x9d, 0x85, 0x13, 0x20, 0x9b, 0x12, 0xd0,
    0x03, 0x4c, 0x0a, 0x12, 0x4c, 0xf0, 0x12, 0x20, 0xbd, 0x12, 0xa9, 0x00, 0x9d, 0x85, 0x13, 0xad,
    0x07, 0x13, 0x0a, 0x0a, 0x9d, 0x81, 0x13, 0xa9, 0x00, 0x9d, 0x87, 0x13, 0x9d, 0x8f, 0x13, 0x9d,
    0x90, 0x13, 0x60, 0x20, 0x95, 0x09, 0xac, 0x05, 0x13, 0xb9, 0x01, 0x14, 0x29, 0x02, 0x9d, 0x84,
    0x13, 0xb9, 0x04, 0x14, 0x9d, 0x8b, 0x13, 0xb9, 0x05, 0x14, 0x9d, 0x8c, 0x13, 0x20, 0x17, 0x10,
    0x60, 0x8d, 0x08, 0x13, 0xbd, 0x41, 0x03, 0x85, 0x21, 0x20, 0x64, 0x11, 0xac, 0x00, 0x13, 0xb9,
    0x02, 0x01, 0xc9, 0xdf, 0xb0, 0x04, 0xa9, 0x00, 0x85, 0x22, 0xbd, 0x82, 0x13, 0x29, 0x08, 0xf0,
    0x2d, 0xbc, 0x87, 0x13, 0x98, 0xdd, 0x86, 0x13, 0x90, 0x11, 0x20, 0x94, 0x0f, 0xb0, 0x22, 0x20,
    0x1f, 0x0a, 0xa0, 0x00, 0xb0, 0x05, 0xb1, 0x24, 0x8d, 0x08, 0x13, 0xfe, 0x87, 0x13, 0xad, 0x08,
    0x13, 0x91, 0x47, 0xa9, 0x40, 0x1d, 0x85, 0x13, 0x9d, 0x85, 0x13, 0x4c, 0xf0, 0x12, 0x4c, 0xbf,
    0x12, 0x4c, 0xf4, 0x12, 0xbd, 0x85, 0x13, 0x10, 0x26, 0x30, 0x02, 0xa9, 0x00, 0x8d, 0x10, 0x13,
    0xa5, 0x22, 0x29, 0x02, 0xf0, 0x19, 0x20, 0xae, 0x0a, 0xb0, 0x14, 0xa5, 0x24, 0x85, 0x47, 0xa5,
    0x25, 0x85, 0x48, 0xad, 0x10, 0x13, 0x30, 0x09, 0x20, 0x0f, 0x10, 0x90, 0x33, 0xb0, 0x53, 0x38,
    0x60, 0xad, 0xf8, 0x12, 0x9d, 0x87, 0x13, 0xa8, 0xb1, 0x47, 0x8d, 0x09, 0x13, 0xc8, 0xb1, 0x47,
    0x8d, 0x0a, 0x13, 0xc8, 0xb1, 0x47, 0x8d, 0x0b, 0x13, 0x20, 0x94, 0x0f, 0xac, 0xf8, 0x12, 0xad,
    0x09, 0x13, 0x91, 0x47, 0xc8, 0xad, 0x0a, 0x13, 0x91, 0x47, 0xc8, 0xad, 0x0b, 0x13, 0x91, 0x47,
    0x18, 0xa5, 0x47, 0x7d, 0x86, 0x13, 0x85, 0x47, 0xa5, 0x48, 0x69, 0x00, 0x85, 0x48, 0x38, 0xa5,
    0x28, 0xfd, 0x86, 0x13, 0x85, 0x28, 0xa5, 0x29, 0xe9, 0x00, 0xea, 0x85, 0x29, 0x20, 0xae, 0x0a,
    0x90, 0xa1, 0xa5, 0x47, 0x85, 0x24, 0xa5, 0x48, 0x85, 0x25, 0xbc, 0x88, 0x13, 0x88, 0x20, 0xd0,
    0x11, 0x18, 0x60, 0xad, 0xfe, 0x12, 0xc9, 0x01, 0xd0, 0x04, 0xa5, 0x28, 0x30, 0xf3, 0xa5, 0x29,
    0xd0, 0xef, 0x38, 0x60, 0x20, 0x64, 0x11, 0xbd, 0x82, 0x13, 0x29, 0x02, 0xf0, 0x03, 0x4c, 0xb9,
    0x0d, 0xbd, 0x87, 0x13, 0xdd, 0x86, 0x13, 0x90, 0x0b, 0x20, 0x26, 0x0a, 0x20, 0x0f, 0x10, 0x90,
    0xf0, 0x4c, 0xf4, 0x12, 0xa8, 0xb1, 0x47, 0x8d, 0x08, 0x13, 0xc8, 0x98, 0x9d, 0x87, 0x13, 0xbc,
    0x8b, 0x13, 0xd0, 0x0f, 0xbc, 0x8c, 0x13, 0xd0, 0x0a, 0xdd, 0x86, 0x13, 0x90, 0x05, 0xa9, 0x03,
    0x4c, 0xd3, 0x12, 0x4c, 0xf0, 0x12, 0x20, 0x64, 0x11, 0x20, 0x9e, 0x0e, 0x20, 0x21, 0x0f, 0xb0,
    0x06, 0x20, 0xac, 0x0c, 0x4c, 0xf0, 0x12, 0x4c, 0xbb, 0x12, 0x20, 0x64, 0x11, 0xbd, 0x82, 0x13,
    0x29, 0x08, 0xf0, 0x4e, 0x3e, 0x85, 0x13, 0x90, 0x51, 0x20, 0xab, 0x0f, 0x20, 0x80, 0x0b, 0xbd,
    0x90, 0x13, 0x48, 0xbd, 0x8f, 0x13, 0x48, 0xbd, 0x82, 0x13, 0x29, 0x01, 0xf0, 0x17, 0x20, 0xae,
    0x09, 0x20, 0x0f, 0x10, 0x90, 0xfb, 0xbd, 0x8d, 0x13, 0x9d, 0x8b, 0x13, 0xbd, 0x8e, 0x13, 0x9d,
    0x8c, 0x13, 0x20, 0xb3, 0x0f, 0xac, 0x05, 0x13, 0x18, 0x68, 0x79, 0x02, 0x14, 0x99, 0x02, 0x14,
    0x68, 0x79, 0x03, 0x14, 0x99, 0x03, 0x14, 0xa9, 0x42, 0x99, 0x01, 0x14, 0x20, 0x71, 0x10, 0x20,
    0x95, 0x10, 0xa9, 0x00, 0x9d, 0x82, 0x13, 0x4c, 0xea, 0x12, 0x3e, 0x85, 0x13, 0x90, 0xf3, 0x20,
    0xf8, 0x0f, 0x4c, 0x6d, 0x0b, 0xbd, 0x81, 0x13, 0x4a, 0x4a, 0x8d, 0x07, 0x13, 0x20, 0x9b, 0x0b,
    0x8d, 0x06, 0x13, 0x20, 0x9b, 0x0b, 0x20, 0x9d, 0x0b, 0x0a, 0x8d, 0x05, 0x13, 0x4c, 0x6e, 0x10,
    0xa9, 0x00, 0xa0, 0x03, 0x1e, 0x81, 0x13, 0x2a, 0x88, 0xd0, 0xf9, 0x60, 0x20, 0x64, 0x11, 0xbd,
    0x42, 0x03, 0xc9, 0xfe, 0xf0, 0x25, 0xc9, 0x27, 0xb0, 0x1e, 0x38, 0xe9, 0x20, 0x90, 0x19, 0x0a,
    0xa8, 0xb9, 0xc5, 0x0b, 0x48, 0xb9, 0xc6, 0x0b, 0x48, 0x60, 0x0b, 0xd8, 0x0c, 0x31, 0x0b, 0xd2,
    0x0c, 0x7b, 0x0c, 0x82, 0x0c, 0xb9, 0x0d, 0x02, 0x4c, 0xbf, 0x12, 0x4c, 0x18, 0x0d, 0x20, 0x9e,
    0x0e, 0x8c, 0x0d, 0x13, 0x20, 0x21, 0x0f, 0x90, 0x03, 0x4c, 0xbb, 0x12, 0x20, 0xac, 0x0c, 0x20,
    0x9b, 0x12, 0xd0, 0x03, 0x20, 0x19, 0x12, 0xac, 0x0d, 0x13, 0x20, 0xb4, 0x0e, 0x20, 0x9b, 0x12,
    0xd0, 0x0f, 0xac, 0x05, 0x13, 0xb9, 0x05, 0x14, 0x48, 0xb9, 0x04, 0x14, 0xa8, 0x68, 0x20, 0x53,
    0x12, 0xa2, 0x00, 0xac, 0x05, 0x13, 0xbd, 0x59, 0x13, 0xc9, 0x3f, 0xf0, 0x03, 0x99, 0x06, 0x14,
    0xc8, 0xe8, 0xe0, 0x0b, 0x90, 0xf0, 0xae, 0x01, 0x13, 0x20, 0x71, 0x10, 0x20, 0x9e, 0x0e, 0x20,
    0x31, 0x0f, 0x90, 0xb8, 0x4c, 0xea, 0x12, 0x20, 0x9e, 0x0e, 0x20, 0x21, 0x0f, 0xb0, 0x3f, 0x20,
    0x53, 0x0c, 0x20, 0x9b, 0x12, 0xd0, 0x03, 0x20, 0x19, 0x12, 0x20, 0x71, 0x10, 0x20, 0x31, 0x0f,
    0x90, 0xed, 0x20, 0x95, 0x10, 0x4c, 0xea, 0x12, 0x20, 0xbf, 0x10, 0xac, 0x05, 0x13, 0x20, 0xac,
    0x0c, 0xa9, 0x80, 0x99, 0x01, 0x14, 0x20, 0xae, 0x09, 0x4c, 0x6c, 0x0c, 0x20, 0x0f, 0x10, 0xb0,
    0x06, 0x20, 0xc5, 0x10, 0x4c, 0x67, 0x0c, 0xa0, 0x05, 0xa9, 0xff, 0x91, 0x45, 0x60, 0x4c, 0xbb,
    0x12, 0xa9, 0x20, 0x8d, 0x0f, 0x13, 0xd0, 0x05, 0xa9, 0x00, 0x8d, 0x0f, 0x13, 0x20, 0x9e, 0x0e,
    0x20, 0x21, 0x0f, 0x90, 0x03, 0x4c, 0xbb, 0x12, 0xac, 0x05, 0x13, 0xb9, 0x01, 0x14, 0x29, 0xdf,
    0x0d, 0x0f, 0x13, 0x99, 0x01, 0x14, 0x20, 0x71, 0x10, 0x20, 0x31, 0x0f, 0x90, 0xea, 0x4c, 0xea,
    0x12, 0xac, 0x05, 0x13, 0xb9, 0x01, 0x14, 0x29, 0x20, 0xd0, 0x01, 0x60, 0x4c, 0xc1, 0x12, 0xbd,
    0x85, 0x13, 0x30, 0x41, 0xbd, 0x4d, 0x03, 0xdd, 0x8a, 0x13, 0xd0, 0x08, 0xbd, 0x4c, 0x03, 0xdd,
    0x89, 0x13, 0xf0, 0x1e, 0xbd, 0x85, 0x13, 0xf0, 0x08, 0x20, 0xf8, 0x0f, 0xa9, 0x00, 0x9d, 0x85,
    0x13, 0xbd, 0x4d, 0x03, 0x9d, 0x8c, 0x13, 0xbd, 0x4c, 0x03, 0x9d, 0x8b, 0x13, 0x20, 0x17, 0x10,
    0xb0, 0x0a, 0xbd, 0x4e, 0x03, 0xdd, 0x86, 0x13, 0x90, 0x05, 0xf0, 0x03, 0x4c, 0xc3, 0x12, 0x9d,
    0x87, 0x13, 0x4c, 0xf0, 0x12, 0x4c, 0xb9, 0x12, 0xbd, 0x87, 0x13, 0x9d, 0x4e, 0x03, 0xbd, 0x89,
    0x13, 0x9d, 0x4c, 0x03, 0xbd, 0x8a, 0x13, 0x9d, 0x4d, 0x03, 0x4c, 0xf0, 0x12, 0xa5, 0x48, 0x8d,
    0x05, 0x03, 0xa5, 0x47, 0x8d, 0x04, 0x03, 0xa9, 0x21, 0x8d, 0x02, 0x03, 0xa9, 0x40, 0x8d, 0x03,
    0x03, 0xae, 0xfe, 0x12, 0xa9, 0x31, 0xac, 0x46, 0x02, 0x20, 0x86, 0x07, 0x10, 0x19, 0xc0, 0x90,
    0xd0, 0x12, 0xa0, 0x00, 0xb1, 0x47, 0xc9, 0xff, 0xd0, 0x07, 0xc8, 0xb1, 0x47, 0xc9, 0xff, 0xf0,
    0x03, 0x4c, 0xb5, 0x12, 0x4c, 0xd3, 0x12, 0xa9, 0x00, 0xa8, 0x91, 0x45, 0xc8, 0x10, 0xfb, 0xa0,
    0x00, 0xa9, 0x02, 0x91, 0x45, 0xc8, 0xa9, 0xc3, 0x91, 0x45, 0xc8, 0xc8, 0x91, 0x45, 0xa9, 0x02,
    0x88, 0x91, 0x45, 0xc8, 0xc8, 0x91, 0x45, 0xa0, 0x0a, 0xa9, 0xff, 0x91, 0x45, 0xc8, 0xc0, 0x64,
    0xd0, 0xf9, 0xa9, 0x0f, 0xa0, 0x0a, 0x91, 0x45, 0xa0, 0x37, 0xa9, 0x00, 0x91, 0x45, 0xc8, 0xa9,
    0x7f, 0x91, 0x45, 0x20, 0x95, 0x10, 0xa9, 0x00, 0xa8, 0x99, 0x01, 0x14, 0xc8, 0x10, 0xfa, 0xa9,
    0x07, 0x8d, 0x06, 0x13, 0x20, 0x71, 0x10, 0xce, 0x06, 0x13, 0x10, 0xf8, 0x20, 0x19, 0x12, 0x4c,
    0xea, 0x12, 0xa9, 0x00, 0x8d, 0x0f, 0x13, 0x20, 0x21, 0x0f, 0x90, 0x2c, 0xb0, 0x30, 0x2c, 0x0f,
    0x13, 0x30, 0x53, 0xac, 0x0f, 0x13, 0xb1, 0x47, 0x8d, 0x08, 0x13, 0xee, 0x0f, 0x13, 0xc9, 0x9b,
    0xd0, 0x09, 0xc0, 0x11, 0xb0, 0x08, 0xa9, 0x80, 0x8d, 0x0f, 0x13, 0x4c, 0xf0, 0x12, 0xa9, 0x00,
    0x8d, 0x0f, 0x13, 0x20, 0x31, 0x0f, 0xb0, 0x06, 0x20, 0x21, 0x0e, 0x4c, 0xf0, 0x12, 0x20, 0x8b,
    0x10, 0xa0, 0x04, 0xb1, 0x45, 0x48, 0x88, 0xb1, 0x45, 0xa8, 0x68, 0x20, 0x57, 0x0e, 0xa0, 0x03,
    0xa2, 0x0c, 0xbd, 0x14, 0x0e, 0x91, 0x47, 0xc8, 0xca, 0x10, 0xf7, 0x20, 0x67, 0x0e, 0xa9, 0x00,
    0x8d, 0x0f, 0x13, 0x4c, 0xea, 0x12, 0x4c, 0xf4, 0x12, 0x53, 0x52, 0x4f, 0x54, 0x43, 0x45, 0x53,
    0x20, 0x45, 0x45, 0x52, 0x46, 0x20, 0xa0, 0x00, 0xa9, 0x20, 0x91, 0x47, 0xae, 0x05, 0x13, 0xbd,
    0x01, 0x14, 0x29, 0x20, 0xf0, 0x04, 0xa9, 0x2a, 0x91, 0x47, 0xc8, 0xa9, 0x20, 0x91, 0x47, 0xc8,
    0xbd, 0x06, 0x14, 0x91, 0x47, 0xe8, 0xc8, 0xc0, 0x0d, 0x90, 0xf5, 0xa9, 0x20, 0x91, 0x47, 0xc8,
    0x8c, 0x0f, 0x13, 0xae, 0x05, 0x13, 0xbc, 0x02, 0x14, 0xbd, 0x03, 0x14, 0xa2, 0x64, 0x20, 0x71,
    0x0e, 0xa2, 0x0a, 0x20, 0x71, 0x0e, 0x98, 0x20, 0x8d, 0x0e, 0xa0, 0x11, 0xa9, 0x9b, 0x91, 0x47,
    0xa0, 0x00, 0x8c, 0x0f, 0x13, 0x60, 0x8e, 0x0e, 0x13, 0xa2, 0xff, 0x8d, 0x0d, 0x13, 0x8c, 0x0c,
    0x13, 0xe8, 0x38, 0xad, 0x0c, 0x13, 0xed, 0x0e, 0x13, 0xa8, 0xad, 0x0d, 0x13, 0xe9, 0x00, 0xb0,
    0xea, 0x8a, 0x09, 0x30, 0xac, 0x0f, 0x13, 0x91, 0x47, 0xee, 0x0f, 0x13, 0xad, 0x0d, 0x13, 0xac,
    0x0c, 0x13, 0x60, 0xbd, 0x44, 0x03, 0x85, 0x43, 0xbd, 0x45, 0x03, 0x85, 0x44, 0xa0, 0x02, 0xb1,
    0x43, 0x88, 0x30, 0x58, 0xc9, 0x3a, 0xd0, 0xf7, 0xc8, 0xa2, 0x0b, 0xa9, 0x20, 0x9d, 0x59, 0x13,
    0xca, 0x10, 0xfa, 0xa2, 0x00, 0x8e, 0x0c, 0x13, 0xc8, 0xb1, 0x43, 0xc9, 0x2a, 0xd0, 0x0b, 0xa9,
    0x3f, 0x20, 0x0a, 0x0f, 0x90, 0xf9, 0x10, 0xf0, 0x30, 0x2e, 0xc9, 0x2e, 0xd0, 0x0c, 0x2c, 0x0c,
    0x13, 0x30, 0x25, 0xa2, 0x08, 0x6e, 0x0c, 0x13, 0x90, 0xde, 0xc9, 0x3f, 0xf0, 0x14, 0xc9, 0x41,
    0x90, 0x04, 0xc9, 0x5b, 0x90, 0x0c, 0xe0, 0x00, 0xf0, 0x12, 0xc9, 0x30, 0x90, 0x0a, 0xc9, 0x3a,
    0xb0, 0x06, 0x20, 0x0a, 0x0f, 0x4c, 0xc3, 0x0e, 0xae, 0x01, 0x13, 0x60, 0x4c, 0xc5, 0x12, 0xe0,
    0x08, 0x90, 0x0d, 0xf0, 0x05, 0xe0, 0x0c, 0x90, 0x07, 0x60, 0x2c, 0x0c, 0x13, 0x30, 0x01, 0x60,
    0x9d, 0x59, 0x13, 0xe8, 0x18, 0x60, 0xa9, 0xff, 0x8d, 0x02, 0x13, 0x8d, 0x06, 0x13, 0x8d, 0x07,
    0x13, 0xa9, 0x70, 0x8d, 0x05, 0x13, 0xee, 0x07, 0x13, 0x18, 0xad, 0x05, 0x13, 0x69, 0x10, 0x10,
    0x11, 0xee, 0x06, 0x13, 0xa9, 0x08, 0xcd, 0x06, 0x13, 0x90, 0x02, 0xf0, 0x48, 0x20, 0x6e, 0x10,
    0xa9, 0x00, 0x8d, 0x05, 0x13, 0xa8, 0xb9, 0x01, 0x14, 0xf0, 0x1d, 0x30, 0x1b, 0x29, 0x01, 0xd0,
    0xd5, 0xa2, 0x00, 0xbd, 0x59, 0x13, 0xc9, 0x3f, 0xf0, 0x05, 0xd9, 0x06, 0x14, 0xd0, 0xc7, 0xe8,
    0xc8, 0xe0, 0x0b, 0xd0, 0xee, 0x18, 0x90, 0x1d, 0xad, 0x02, 0x13, 0x10, 0x12, 0xad, 0x06, 0x13,
    0x8d, 0x02, 0x13, 0xad, 0x05, 0x13, 0x8d, 0x03, 0x13, 0xad, 0x07, 0x13, 0x8d, 0x04, 0x13, 0xb9,
    0x01, 0x14, 0x30, 0xa2, 0x38, 0xae, 0x01, 0x13, 0x60, 0xbd, 0x85, 0x13, 0x30, 0x0f, 0x0a, 0x10,
    0x09, 0x0a, 0x9d, 0x85, 0x13, 0x20, 0xf8, 0x0f, 0x30, 0x24, 0x4c, 0x0f, 0x10, 0x20, 0x06, 0x11,
    0xbd, 0x87, 0x13, 0xac, 0xfb, 0x12, 0x91, 0x47, 0xbd, 0x8c, 0x13, 0x1d, 0x81, 0x13, 0xac, 0xf8,
    0x12, 0x91, 0x47, 0xc8, 0xbd, 0x8b, 0x13, 0x91, 0x47, 0x20, 0xf8, 0x0f, 0x10, 0x11, 0xad, 0x03,
    0x03, 0x8d, 0x0f, 0x13, 0xa9, 0x00, 0x9d, 0x82, 0x13, 0xad, 0x0f, 0x13, 0x4c, 0xd3, 0x12, 0xfe,
    0x8f, 0x13, 0xd0, 0x03, 0xfe, 0x90, 0x13, 0x20, 0x02, 0x10, 0xa9, 0x00, 0x9d, 0x8b, 0x13, 0x9d,
    0x8c, 0x13, 0x9d, 0x87, 0x13, 0xad, 0xf8, 0x12, 0x9d, 0x86, 0x13, 0x18, 0x60, 0x38, 0xbd, 0x8a,
    0x13, 0xbc, 0x89, 0x13, 0x4c, 0xf7, 0x11, 0xbd, 0x8b, 0x13, 0x9d, 0x89, 0x13, 0xbd, 0x8c, 0x13,
    0x9d, 0x8a, 0x13, 0x60, 0xbd, 0x85, 0x13, 0xf0, 0x03, 0x4c, 0x94, 0x0f, 0xbd, 0x8b, 0x13, 0x1d,
    0x8c, 0x13, 0xd0, 0x02, 0x38, 0x60, 0x20, 0x02, 0x10, 0x18, 0x20, 0xf9, 0x0f, 0x30, 0x35, 0xac,
    0xf8, 0x12, 0xb1, 0x47, 0x29, 0xfc, 0xdd, 0x81, 0x13, 0xd0, 0x2c, 0xb1, 0x47, 0x29, 0x03, 0x9d,
    0x8c, 0x13, 0xc8, 0xb1, 0x47, 0x9d, 0x8b, 0x13, 0xc8, 0xb1, 0x47, 0x48, 0xbd, 0x84, 0x13, 0xd0,
    0x08, 0x68, 0x30, 0x02, 0xa9, 0x7d, 0x29, 0x7f, 0x48, 0x68, 0x9d, 0x86, 0x13, 0xa9, 0x00, 0x9d,
    0x87, 0x13, 0x18, 0x60, 0x20, 0xe5, 0x12, 0xbd, 0x42, 0x03, 0xc9, 0x21, 0xf0, 0x03, 0x20, 0xc7,
    0x12, 0x38, 0x60, 0x18, 0x90, 0x01, 0x38, 0x08, 0xa9, 0x14, 0x8d, 0x05, 0x03, 0xa9, 0x01, 0x8d,
    0x04, 0x03, 0x18, 0xad, 0x06, 0x13, 0x69, 0x69, 0xa8, 0xa9, 0x01, 0x69, 0x00, 0x4c, 0xab, 0x10,
    0xa0, 0x05, 0xb1, 0x45, 0xf0, 0x01, 0x60, 0x18, 0x90, 0x07, 0xa0, 0x05, 0xa9, 0x00, 0x91, 0x45,
    0x38, 0x08, 0xa5, 0x46, 0x8d, 0x05, 0x03, 0xa5, 0x45, 0x8d, 0x04, 0x03, 0xa0, 0x68, 0xa9, 0x01,
    0x28, 0xae, 0xfe, 0x12, 0x20, 0x6c, 0x07, 0x30, 0x01, 0x60, 0xc9, 0x83, 0xf0, 0x03, 0x4c, 0xe5,
    0x12, 0x4c, 0xc9, 0x12, 0x20, 0x8b, 0x10, 0x4c, 0x95, 0x10, 0xbd, 0x89, 0x13, 0x1d, 0x8a, 0x13,
    0xf0, 0x38, 0xa9, 0x00, 0xa0, 0x03, 0x5e, 0x8a, 0x13, 0x7e, 0x89, 0x13, 0x6a, 0x88, 0xd0, 0xf6,
    0xa0, 0x05, 0x6a, 0x88, 0xd0, 0xfc, 0xa8, 0xa9, 0x00, 0x38, 0x6a, 0x88, 0x10, 0xfc, 0x48, 0xbd,
    0x89, 0x13, 0x69, 0x0a, 0xa8, 0x68, 0x11, 0x45, 0x91, 0x45, 0xa0, 0x03, 0xb1, 0x45, 0x18, 0x69,
    0x01, 0x91, 0x45, 0xc8, 0xb1, 0x45, 0x69, 0x00, 0x91, 0x45, 0x60, 0xa0, 0x09, 0xc8, 0xc0, 0x64,
    0xb0, 0x54, 0xb1, 0x45, 0xf0, 0xf7, 0x8c, 0x0c, 0x13, 0x48, 0x38, 0xa0, 0x03, 0xb1, 0x45, 0xe9,
    0x01, 0x91, 0x45, 0xc8, 0xb1, 0x45, 0xe9, 0x00, 0x91, 0x45, 0xc8, 0xa9, 0xff, 0x91, 0x45, 0x68,
    0xa0, 0xff, 0xc8, 0x0a, 0x90, 0xfc, 0x8c, 0x0d, 0x13, 0x4a, 0x88, 0x10, 0xfc, 0xac, 0x0c, 0x13,
    0x91, 0x45, 0x38, 0xad, 0x0c, 0x13, 0xe9, 0x0a, 0xa0, 0x00, 0x8c, 0x0c, 0x13, 0x0a, 0x2e, 0x0c,
    0x13, 0xc8, 0xc0, 0x03, 0x90, 0xf7, 0x18, 0x6d, 0x0d, 0x13, 0x9d, 0x8b, 0x13, 0xad, 0x0c, 0x13,
    0x69, 0x00, 0x9d, 0x8c, 0x13, 0x60, 0x4c, 0xcb, 0x12, 0xa9, 0x9f, 0x85, 0x49, 0x8e, 0x01, 0x13,
    0xba, 0xe8, 0xe8, 0x8e, 0x00, 0x13, 0xae, 0x01, 0x13, 0xa4, 0x21, 0x8c, 0x01, 0x03, 0x88, 0xb9,
    0x29, 0x13, 0x85, 0x45, 0xb9, 0x31, 0x13, 0x85, 0x46, 0xb9, 0x11, 0x13, 0xf0, 0x52, 0x8d, 0xfe,
    0x12, 0xa8, 0xb9, 0xf8, 0x12, 0x8d, 0xf8, 0x12, 0xb9, 0xfb, 0x12, 0x8d, 0xfb, 0x12, 0xbc, 0x88,
    0x13, 0x88, 0x10, 0x31, 0xa0, 0x00, 0xb9, 0x19, 0x13, 0xf0, 0x08, 0xc8, 0xc0, 0x10, 0x90, 0xf6,
    0x4c, 0xcd, 0x12, 0xad, 0xfe, 0x12, 0x4a, 0xb0, 0x10, 0xc8, 0xc0, 0x10, 0xb0, 0xf2, 0xb9, 0x19,
    0x13, 0xd0, 0xe8, 0x88, 0xa9, 0x80, 0x99, 0x1a, 0x13, 0xa9, 0x80, 0x99, 0x19, 0x13, 0x98, 0x9d,
    0x88, 0x13, 0xfe, 0x88, 0x13, 0xb9, 0x39, 0x13, 0x85, 0x47, 0xb9, 0x49, 0x13, 0x85, 0x48, 0x60,
    0x4c, 0xcf, 0x12, 0xbc, 0x88, 0x13, 0xf0, 0x13, 0x88, 0xa9, 0x00, 0x9d, 0x88, 0x13, 0x99, 0x19,
    0x13, 0xad, 0xfe, 0x12, 0x4a, 0xb0, 0x04, 0x4a, 0x99, 0x1a, 0x13, 0x60, 0x48, 0xa5, 0x47, 0x8d,
    0x04, 0x03, 0xa5, 0x48, 0x8d, 0x05, 0x03, 0x68, 0xae, 0xfe, 0x12, 0x20, 0x6c, 0x07, 0x60, 0xbc,
    0x89, 0x13, 0xbd, 0x8a, 0x13, 0x20, 0x53, 0x12, 0x20, 0x67, 0x12, 0x4c, 0xf0, 0x12, 0xa9, 0x00,
    0x8d, 0x0e, 0x07, 0xa9, 0x07, 0x8d, 0x05, 0x03, 0xa9, 0x00, 0x8d, 0x04, 0x03, 0xa9, 0x00, 0x8d,
    0x0a, 0x03, 0x8d, 0x0b, 0x03, 0xee, 0x0a, 0x03, 0xa2, 0x01, 0x38, 0x20, 0x72, 0x07, 0x18, 0xad,
    0x04, 0x03, 0x69, 0x80, 0x8d, 0x04, 0x03, 0xad, 0x05, 0x03, 0x69, 0x00, 0x8d, 0x05, 0x03, 0xad,
    0x0a, 0x03, 0xcd, 0x01, 0x07, 0xd0, 0xde, 0x60, 0x8c, 0x0f, 0x07, 0x8d, 0x10, 0x07, 0xad, 0xfe,
    0x12, 0x8d, 0x0e, 0x07, 0xac, 0xf8, 0x12, 0x8c, 0x11, 0x07, 0xd0, 0xb4, 0xad, 0x12, 0x07, 0x85,
    0x43, 0xad, 0x13, 0x07, 0x85, 0x44, 0xa0, 0x00, 0xb1, 0x43, 0x91, 0x47, 0xc8, 0xcc, 0xf8, 0x12,
    0x90, 0xf6, 0x98, 0x9d, 0x87, 0x13, 0x20, 0x57, 0x07, 0xcd, 0x0d, 0x07, 0x90, 0x0b, 0xd0, 0x0f,
    0xa5, 0x43, 0xcd, 0x0c, 0x07, 0x90, 0x02, 0xd0, 0x06, 0x20, 0x94, 0x0f, 0x4c, 0x71, 0x12, 0x60,
    0xa0, 0x0b, 0xb9, 0x58, 0x13, 0xd9, 0xa8, 0x12, 0xd0, 0x03, 0x88, 0xd0, 0xf5, 0x60, 0x44, 0x4f,
    0x53, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x59, 0x53, 0x20, 0xe6, 0x49, 0xe6, 0x49, 0xe6, 0x49,
    0xe6, 0x49, 0xe6, 0x49, 0xe6, 0x49, 0xe6, 0x49, 0xe6, 0x49, 0xe6, 0x49, 0xe6, 0x49, 0xe6, 0x49,
    0xe6, 0x49, 0xe6, 0x49, 0xe6, 0x49, 0xa5, 0x49, 0xae, 0x01, 0x13, 0x9d, 0x43, 0x03, 0xae, 0x00,
    0x13, 0x9a, 0xae, 0x01, 0x13, 0xa8, 0xad, 0x08, 0x13, 0x60, 0xad, 0x03, 0x03, 0x30, 0xe9, 0xae,
    0x01, 0x13, 0x20, 0xde, 0x11, 0xa9, 0x01, 0xd0, 0xdf, 0xa9, 0x88, 0x30, 0xdb, 0x7d, 0x7d, 0xfd,
    0x7f, 0x7f, 0xff, 0x01, 0x03, 0xf7, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9b, 0x06, 0xad,
    0x04, 0x00, 0x03, 0x0a, 0x80, 0xc0, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
    0x00, 0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xfc, 0x7c,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xfc,
    0x7c, 0xca, 0x00, 0x00, 0x44, 0x44, 0x4f, 0x53, 0x20, 0x20, 0x20, 0x1c, 0x1c, 0x1d, 0x1b, 0x1b,
    0x1c, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x4f, 0x53, 0x44, 0x4f,
    0x53, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x59, 0x53, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
    0x00, 0x80, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x80, 0x7d, 0x00, 0x01, 0x1c, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7d, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x94, 0x00, 0x00, 0x02, 0x00, 0x7d, 0x7d, 0x00, 0xc7, 0x02,
    0xc7, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x04, 0x00, 0x44, 0x4f, 0x53, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x53, 0x59, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x8d, 0x16, 0x30, 0x15, 0xa0, 0x00, 0x60,
    0xa9, 0x03, 0x9d, 0x42, 0x03, 0xa9, 0x9b, 0x9d, 0x44, 0x03, 0xa9, 0x14, 0x9d, 0x45, 0x03, 0x4c,
    0x56, 0xe4, 0x8c, 0xfc, 0x14, 0x20, 0x8d, 0x16, 0xa9, 0x21, 0x9d, 0x42, 0x03, 0x20, 0xdb, 0x14,
    0xa0, 0x00, 0x60, 0x4c, 0x56, 0xa9, 0x00, 0x8d, 0x55, 0x15, 0xa9, 0x51, 0x85, 0x0a, 0xa9, 0x17,
    0x85, 0x0b, 0xa9, 0x9a, 0x8d, 0x0a, 0x02, 0xa9, 0x19, 0x8d, 0x0b, 0x02, 0xa9, 0x5d, 0x8d, 0x0c,
    0x02, 0xa9, 0x19, 0x8d, 0x0d, 0x02, 0x20, 0xe0, 0x07, 0xa5, 0x08, 0xd0, 0x15, 0xa9, 0xc0, 0x8d,
    0x54, 0x03, 0xa9, 0x16, 0x8d, 0x55, 0x03, 0x20, 0x4a, 0x15, 0xa9, 0xc0, 0x20, 0x5d, 0x15, 0x4c,
    0x21, 0x19, 0xad, 0x54, 0x15, 0xa9, 0x00, 0x8d, 0x9e, 0x15, 0xa9, 0x9f, 0x85, 0x0a, 0xa9, 0x17,
    0x85, 0x0b, 0xa9, 0x23, 0x8d, 0x0a, 0x02, 0xa9, 0x1a, 0x8d, 0x0b, 0x02, 0xa9, 0xe6, 0x8d, 0x0c,
    0x02, 0xa9, 0x19, 0x8d, 0x0d, 0x02, 0x20, 0xe0, 0x07, 0xa5, 0x08, 0xd0, 0x15, 0xa9, 0x0c, 0x8d,
    0x54, 0x03, 0xa9, 0x17, 0x8d, 0x55, 0x03, 0x20, 0x93, 0x15, 0xa9, 0xc0, 0x20, 0xa6, 0x15, 0x4c,
    0xaa, 0x19, 0xad, 0x9d, 0x15, 0xf0, 0x11, 0xad, 0x9e, 0x17, 0xf0, 0x12, 0x20, 0x3f, 0x19, 0x20,
    0x2e, 0x19, 0x20, 0x93, 0x15, 0x20, 0x74, 0xe4, 0xa9, 0x00, 0x8d, 0x9d, 0x15, 0x60, 0x85, 0x08,
    0xf0, 0xf6, 0xff, 0x00, 0x00, 0xe0, 0x02, 0xe1, 0x02, 0xa9, 0x80, 0x8d, 0x9f, 0x15, 0xa9, 0x47,
    0x8d, 0xe0, 0x02, 0xa9, 0x16, 0x8d, 0xe1, 0x02, 0xa2, 0x10, 0xa9, 0x03, 0x9d, 0x42, 0x03, 0xa9,
    0x04, 0x9d, 0x4a, 0x03, 0x20, 0x56, 0xe4, 0x10, 0x04, 0xa9, 0x01, 0xd0, 0x7e, 0xa2, 0x10, 0xa9,
    0xf4, 0x9d, 0x44, 0x03, 0xa9, 0x1d, 0x9d, 0x45, 0x03, 0xa9, 0x02, 0x9d, 0x48, 0x03, 0xa9, 0x00,
    0x9d, 0x49, 0x03, 0x8d, 0x0b, 0x17, 0xa9, 0x07, 0x9d, 0x42, 0x03, 0x20, 0x56, 0xe4, 0x30, 0x64,
    0xa9, 0xff, 0xcd, 0xf4, 0x1d, 0xd0, 0x56, 0xcd, 0xf5, 0x1d, 0xd0, 0x51, 0xa2, 0x10, 0xa9, 0xa0,
    0x9d, 0x44, 0x03, 0xa9, 0x15, 0x9d, 0x45, 0x03, 0xa9, 0x04, 0x9d, 0x48, 0x03, 0xa9, 0x00, 0x9d,
    0x49, 0x03, 0x20, 0x56, 0xe4, 0x10, 0x46, 0xc0, 0x88, 0xd0, 0x39, 0x20, 0xaa, 0x19, 0x2c, 0x9e,
    0x15, 0x30, 0x03, 0x20, 0x08, 0x17, 0xa9, 0x00, 0x2c, 0x9f, 0x15, 0x8d, 0x9f, 0x15, 0x30, 0x1b,
    0x20, 0x73, 0x18, 0x30, 0x05, 0x68, 0x68, 0x4c, 0xb8, 0x17, 0xad, 0x9d, 0x15, 0xd0, 0x0a, 0xa9,
    0x1b, 0xa2, 0x17, 0x20, 0xbe, 0x19, 0x4c, 0x01, 0x18, 0xa9, 0x00, 0xaa, 0x60, 0x20, 0xaa, 0x19,
    0xa9, 0x03, 0xd0, 0xf7, 0x98, 0x48, 0x20, 0xaa, 0x19, 0x68, 0xa8, 0xd0, 0xee, 0xa2, 0x10, 0xad,
    0xa0, 0x15, 0x9d, 0x44, 0x03, 0x48, 0xad, 0xa1, 0x15, 0x9d, 0x45, 0x03, 0xa8, 0x68, 0xc8, 0xd0,
    0x1f, 0xa8, 0xc8, 0xd0, 0x1b, 0xad, 0xa2, 0x15, 0x8d, 0xa0, 0x15, 0xad, 0xa3, 0x15, 0x8d, 0xa1,
    0x15, 0xa9, 0xa2, 0x9d, 0x44, 0x03, 0xa9, 0x15, 0x9d, 0x45, 0x03, 0xa9, 0x02, 0x4c, 0x05, 0x16,
    0xad, 0xa2, 0x15, 0x38, 0xed, 0xa0, 0x15, 0x9d, 0x48, 0x03, 0xad, 0xa3, 0x15, 0xed, 0xa1, 0x15,
    0x9d, 0x49, 0x03, 0xad, 0xa1, 0x15, 0x20, 0xfa, 0x16, 0xb0, 0x15, 0xad, 0xa3, 0x15, 0x20, 0xfa,
    0x16, 0xb0, 0x0d, 0xad, 0x0b, 0x17, 0x30, 0x08, 0xa9, 0x80, 0x0d, 0x9f, 0x15, 0x8d, 0x9f, 0x15,
    0xfe, 0x48, 0x03, 0xd0, 0x03, 0xfe, 0x49, 0x03, 0x2c, 0x9f, 0x15, 0x30, 0x13, 0xad, 0x0b, 0x17,
    0x30, 0x0e, 0xce, 0x0b, 0x17, 0x20, 0x39, 0x19, 0xa9, 0x00, 0x8d, 0x9d, 0x15, 0x20, 0x2e, 0x19,
    0xa2, 0x10, 0xa9, 0x47, 0x8d, 0xe2, 0x02, 0xa9, 0x16, 0x8d, 0xe3, 0x02, 0x20, 0x56, 0xe4, 0x10,
    0x03, 0x4c, 0x4f, 0x16, 0x2c, 0x9e, 0x15, 0x30, 0x03, 0x20, 0x05, 0x17, 0x4c, 0xf7, 0x15, 0xc9,
    0x1d, 0x90, 0x06, 0xc9, 0x34, 0x2a, 0x49, 0x01, 0x4a, 0x60, 0x6c, 0xe2, 0x02, 0x6c, 0xe0, 0x02,
    0x00, 0x44, 0x31, 0x3a, 0x41, 0x55, 0x54, 0x4f, 0x52, 0x55, 0x4e, 0x2e, 0x53, 0x59, 0x53, 0x9b,
    0x4e, 0x45, 0x45, 0x44, 0x20, 0x4d, 0x45, 0x4d, 0x2e, 0x53, 0x41, 0x56, 0x20, 0x54, 0x4f, 0x20,
    0x4c, 0x4f, 0x41, 0x44, 0x20, 0x54, 0x48, 0x49, 0x53, 0x20, 0x46, 0x49, 0x4c, 0x45, 0x2e, 0x9b,
    0x44, 0x31, 0x3a, 0x4d, 0x45, 0x4d, 0x2e, 0x53, 0x41, 0x56, 0x9b, 0x20, 0xaa, 0x19, 0xa9, 0x08,
    0x9d, 0x4a, 0x03, 0x20, 0x79, 0x17, 0x30, 0x38, 0xa9, 0x0b, 0x9d, 0x42, 0x03, 0xa9, 0x7c, 0x9d,
    0x44, 0x03, 0xa9, 0x1d, 0x9d, 0x45, 0x03, 0xa9, 0x8a, 0x9d, 0x48, 0x03, 0xa9, 0x15, 0x9d, 0x49,
    0x03, 0x20, 0x56, 0xe4, 0x30, 0x1a, 0x20, 0xaa, 0x19, 0x30, 0x15, 0xa0, 0x00, 0x60, 0xa9, 0x03,
    0x9d, 0x42, 0x03, 0xa9, 0x3b, 0x9d, 0x44, 0x03, 0xa9, 0x17, 0x9d, 0x45, 0x03, 0x4c, 0x56, 0xe4,
    0x8c, 0x9a, 0x17, 0x20, 0xaa, 0x19, 0xa9, 0x21, 0x9d, 0x42, 0x03, 0x20, 0x79, 0x17, 0xa0, 0x00,
    0x60, 0x40, 0x15, 0x00, 0xa2, 0x00, 0x8e, 0x9e, 0x17, 0x8e, 0x9f, 0x15, 0xca, 0x86, 0x08, 0x20,
    0x76, 0x19, 0x20, 0x73, 0x18, 0x10, 0x06, 0xa9, 0x00, 0x85, 0x08, 0xf0, 0x3f, 0x20, 0x46, 0x17,
    0x30, 0x05, 0xce, 0x9e, 0x17, 0x30, 0x35, 0xa9, 0x3a, 0xa2, 0x18, 0x20, 0xbe, 0x19, 0xa9, 0x5b,
    0xa2, 0x18, 0x20, 0xbe, 0x19, 0xa9, 0x05, 0x8d, 0x42, 0x03, 0xa9, 0x00, 0x8d, 0x44, 0x03, 0xa9,
    0x01, 0x8d, 0x45, 0x03, 0xa9, 0x02, 0x8d, 0x48, 0x03, 0xa9, 0x00, 0x8d, 0x49, 0x03, 0x20, 0x56,
    0xe4, 0xad, 0x00, 0x01, 0xc9, 0x59, 0xd0, 0x38, 0xa9, 0x00, 0x85, 0x08, 0xa2, 0x20, 0xa9, 0x0c,
    0x9d, 0x42, 0x03, 0x20, 0x56, 0xe4, 0xa5, 0x0c, 0x8d, 0x9c, 0x17, 0xa5, 0x0d, 0x8d, 0x9d, 0x17,
    0xa9, 0x40, 0x85, 0x0c, 0xa9, 0x15, 0x85, 0x0d, 0xa9, 0x2f, 0xa2, 0x10, 0x9d, 0x44, 0x03, 0xa9,
    0x18, 0x9d, 0x45, 0x03, 0xa0, 0x00, 0x8c, 0x9e, 0x15, 0x88, 0x8c, 0x9d, 0x15, 0x20, 0xa4, 0x15,
    0x60, 0x45, 0x3a, 0x9b, 0x44, 0x31, 0x3a, 0x44, 0x55, 0x50, 0x2e, 0x53, 0x59, 0x53, 0x9b, 0x45,
    0x52, 0x52, 0x4f, 0x52, 0x2d, 0x53, 0x41, 0x56, 0x49, 0x4e, 0x47, 0x20, 0x55, 0x53, 0x45, 0x52,
    0x20, 0x4d, 0x45, 0x4d, 0x4f, 0x52, 0x59, 0x20, 0x4f, 0x4e, 0x20, 0x44, 0x49, 0x53, 0x4b, 0x9b,
    0x54, 0x59, 0x50, 0x45, 0x20, 0x59, 0x20, 0x54, 0x4f, 0x20, 0x53, 0x54, 0x49, 0x4c, 0x4c, 0x20,
    0x52, 0x55, 0x4e, 0x20, 0x44, 0x4f, 0x53, 0x9b, 0x20, 0xb4, 0x19, 0xa9, 0x03, 0x9d, 0x42, 0x03,
    0xa9, 0x3b, 0x9d, 0x44, 0x03, 0xa9, 0x17, 0x9d, 0x45, 0x03, 0xa9, 0x0c, 0x9d, 0x4a, 0x03, 0x20,
    0x56, 0xe4, 0x08, 0x20, 0xb4, 0x19, 0x28, 0x60, 0xa9, 0x00, 0xf0, 0x03, 0x20, 0x39, 0x19, 0xa2,
    0x10, 0x20, 0x56, 0xe4, 0xa9, 0x00, 0xf0, 0x1a, 0xee, 0xa0, 0x18, 0xad, 0xe2, 0x02, 0x8d, 0xe4,
    0x19, 0xad, 0xe3, 0x02, 0x8d, 0xe5, 0x19, 0xa9, 0xe2, 0xaa, 0x8d, 0xe0, 0x19, 0xa9, 0x02, 0x20,
    0xef, 0x18, 0xa9, 0x00, 0xf0, 0x1a, 0xee, 0xbe, 0x18, 0xad, 0xe0, 0x02, 0x8d, 0xe4, 0x19, 0xad,
    0xe1, 0x02, 0x8d, 0xe5, 0x19, 0xa9, 0xe0, 0xaa, 0x8d, 0xe0, 0x19, 0xa9, 0x02, 0x20, 0xef, 0x18,
    0x20, 0xaa, 0x19, 0xad, 0x9e, 0x17, 0x2d, 0x94, 0x18, 0xf0, 0x06, 0xee, 0x94, 0x18, 0x4c, 0x13,
    0x18, 0x4c, 0x75, 0x20, 0x8d, 0xe1, 0x19, 0xe8, 0x8e, 0xe2, 0x19, 0x8d, 0xe3, 0x19, 0xa2, 0x10,
    0xa9, 0xe0, 0x9d, 0x44, 0x03, 0xa9, 0x19, 0x9d, 0x45, 0x03, 0xa9, 0x06, 0x9d, 0x48, 0x03, 0xa9,
    0x00, 0x9d, 0x49, 0x03, 0x4c, 0x56, 0xe4, 0x20, 0x39, 0x19, 0xa9, 0x00, 0x8d, 0x9d, 0x15, 0x20,
    0x2e, 0x19, 0x6c, 0xfa, 0xbf, 0x20, 0x39, 0x19, 0xa9, 0x00, 0x8d, 0x9d, 0x15, 0x20, 0x2e, 0x19,
    0x6c, 0x1a, 0x00, 0xad, 0x9c, 0x17, 0x85, 0x0c, 0xad, 0x9d, 0x17, 0x85, 0x0d, 0x60, 0xad, 0x9e,
    0x17, 0xd0, 0x01, 0x60, 0x20, 0x73, 0x18, 0x10, 0x06, 0xa9, 0x00, 0x85, 0x08, 0xf0, 0x24, 0xa9,
    0x03, 0x9d, 0x42, 0x03, 0x20, 0x56, 0xe4, 0xa9, 0x07, 0x9d, 0x42, 0x03, 0xa9, 0x8a, 0x9d, 0x48,
    0x03, 0xa9, 0x15, 0x9d, 0x49, 0x03, 0xa9, 0x7c, 0x9d, 0x44, 0x03, 0xa9, 0x1d, 0x9d, 0x45, 0x03,
    0x20, 0x56, 0xe4, 0xa9, 0x0c, 0x9d, 0x42, 0x03, 0x4c, 0x56, 0xe4, 0x20, 0x6e, 0xe4, 0xa2, 0x00,
    0xa9, 0x03, 0x9d, 0x42, 0x03, 0xa9, 0x2c, 0x9d, 0x44, 0x03, 0xa9, 0x18, 0x9d, 0x45, 0x03, 0xa9,
    0x0c, 0x9d, 0x4a, 0x03, 0x20, 0x56, 0xe4, 0xa2, 0x00, 0x8e, 0x1c, 0x02, 0x8e, 0x1d, 0x02, 0xa0,
    0x01, 0xa9, 0x03, 0x8d, 0x2a, 0x02, 0x20, 0x5c, 0xe4, 0xad, 0x2a, 0x02, 0xd0, 0xfb, 0x60, 0xa9,
    0x0c, 0xa2, 0x10, 0x9d, 0x42, 0x03, 0x20, 0x56, 0xe4, 0xa2, 0x20, 0xa9, 0x0c, 0x9d, 0x42, 0x03,
    0x4c, 0x56, 0xe4, 0x8d, 0x44, 0x03, 0x8e, 0x45, 0x03, 0xa9, 0x80, 0x8d, 0x48, 0x03, 0xa2, 0x00,
    0x8e, 0x49, 0x03, 0xa9, 0x09, 0x8d, 0x42, 0x03, 0xad, 0x9d, 0x15, 0xd0, 0x03, 0x4c, 0x56, 0xe4,
    0x4c, 0xaa, 0x31, 0xff, 0xff, 0xe0, 0x02, 0xe1, 0x02, 0x75, 0x20, 0x98, 0x48, 0xe6, 0x32, 0xd0,
    0x02, 0xe6, 0x33, 0xa5, 0x32, 0xc5, 0x34, 0xa5, 0x33, 0xe5, 0x35, 0x90, 0x1a, 0xa5, 0x3b, 0xd0,
    0x09, 0xa5, 0x31, 0x8d, 0x0d, 0xd2, 0xc6, 0x3b, 0xd0, 0x09, 0xa5, 0x10, 0x09, 0x08, 0x85, 0x10,
    0x8d, 0x0e, 0xd2, 0x68, 0xa8, 0x68, 0x40, 0xa0, 0x00, 0xb1, 0x32, 0x8d, 0x0d, 0xd2, 0x18, 0x65,
    0x31, 0x69, 0x00, 0x85, 0x31, 0x4c, 0x0e, 0x1a, 0x98, 0x48, 0xad, 0x0f, 0xd2, 0x8d, 0x0a, 0xd2,
    0x30, 0x04, 0xa0, 0x8c, 0x84, 0x30, 0x29, 0x20, 0xd0, 0x04, 0xa0, 0x8e, 0x84, 0x30, 0xa5, 0x38,
    0xf0, 0x13, 0xad, 0x0d, 0xd2, 0xc5, 0x31, 0xf0, 0x04, 0xa0, 0x8f, 0x84, 0x30, 0xa9, 0xff, 0x85,
    0x39, 0x68, 0xa8, 0x68, 0x40, 0xad, 0x0d, 0xd2, 0xa0, 0x00, 0x91, 0x32, 0x18, 0x65, 0x31, 0x69,
    0x00, 0x85, 0x31, 0xe6, 0x32, 0xd0, 0x02, 0xe6, 0x33, 0xa5, 0x32, 0xc5, 0x34, 0xa5, 0x33, 0xe5,
    0x35, 0x90, 0xde, 0xa5, 0x3c, 0xf0, 0x06, 0xa9, 0x00, 0x85, 0x3c, 0xf0, 0xd0, 0xc6, 0x38, 0xd0,
    0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

#if 0   // this attempt to run a BASIC program w/o DOS by loading a tokenized file by hand failed
BYTE Bas1[128] = {
    0x00, 0x03, 0x00, 0x06, 0x06, 0x06, 0xAD, 0xE7, 0x02, 0x85, 0x80, 0xAD, 0xE8, 0x02, 0x85, 0x81,
    0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xA9, 0x31, 0x8D, 0x00, 0x03, 0xA9, 0x01, 0x8D, 0x01, 0x03,
    0xA9, 0x52, 0x8D, 0x02, 0x03, 0xA9, 0x40, 0x8D, 0x03, 0x03, 0xA9, 0x00, 0x8D, 0x04, 0x03, 0xA9,
    0x04, 0x8D, 0x05, 0x03, 0xA9, 0x80, 0x8D, 0x08, 0x03, 0xA9, 0x00, 0x8D, 0x09, 0x03, 0xA9, 0x04,
    0x8D, 0x0A, 0x03, 0xA9, 0x00, 0x8D, 0x0B, 0x03, 0x20, 0x59, 0xE4, 0xA0, 0x00, 0xA2, 0x02, 0xBD,
    0x00, 0x04, 0x18, 0x65, 0x80, 0x95, 0x80, 0xBD, 0x01, 0x04, 0x65, 0x81, 0x95, 0x81, 0xE8, 0xE8,
    0xE0, 0x0E, 0xD0, 0xEB, 0xA5, 0x82, 0x85, 0x0E, 0xA5, 0x83, 0x85, 0x0F, 0xA2, 0x0E, 0xA0, 0x00,
    0xBD, 0x00, 0x04, 0x91, 0x0E, 0xE6, 0x0E, 0xD0, 0x02, 0xE6, 0x0F, 0xA5, 0x0E, 0xC5, 0x8C, 0xD0 };

BYTE Bas2[128] = {
    0x09, 0xA5, 0x0F, 0xC5, 0x8D, 0xD0, 0x03, 0xF0, 0x17, 0xEA, 0xE8, 0xE0, 0x7D, 0xD0, 0xE1, 0xEE,
    0x0A, 0x03, 0xD0, 0x03, 0xEE, 0x0B, 0x03, 0x20, 0x59, 0xE4, 0xA2, 0x00, 0xA0, 0x00, 0xF0, 0xD0,
    0xA9, 0x01, 0x85, 0x08, 0x18, 0x60, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

BYTE Bas3[128] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
#endif

// is this 128 byte buffer empty?
BOOL IsEmpty(char *cc)
{
    for (int i = 0; i < 128; i++)
    {
        if (cc[i])
            return FALSE;
    }
    return TRUE;
}

BOOL GetWriteProtectDrive(int iVM, int i)
{
    return rgDrives[iVM][i].fWP;
}

BOOL SetWriteProtectDrive(int iVM, int i, BOOL fWP)
{
    WORD mode = rgDrives[iVM][i].mode;
    // you can't un-write protect a binary file masquerading as a disk image, bad things will happen
    if ((mode != MD_FILE && mode != MD_FILEBIN && mode != MD_FILEBAS) || fWP)
        rgDrives[iVM][i].fWP = (WORD)fWP;
    return rgDrives[iVM][i].fWP;
}

// make an ATARI compatible filename - 8.3 without the dot
void AtariFNFromPath(int iVM, int i, BYTE *spec)
{
    // start with every filename character a space
    int l, d, s, m;
    for (l = 0; l < 11; l++)
        rgDrives[iVM][i].name[l] = ' ';
    rgDrives[iVM][i].name[11] = 0;

    // look backwards for a '.' or '\'

    d = lstrlen((LPCSTR)spec);  // if no . found, assume dot is after the end
    l = d - 1;
    m = d;

    while (l > 0 && spec[l] != '.' && spec[l] != '\\')
        l--;
    
    // . means we found an extension for positions 8-10
    if (l > 0 && spec[l] == '.')
    {
        d = l;
        for (s = 1; s < 4 && l + s < m; s++)
        {
            if (spec[l + s] >= 'a' && spec[l + s] <= 'z')
                rgDrives[iVM][i].name[7 + s] = spec[l + s] - 'a' + 'A';    // only upper case allowed
            else if ((spec[l + s] >= 'A' && spec[l + s] <= 'Z') || (spec[l + s] >= '0' && spec[l + s] <= '9'))
                rgDrives[iVM][i].name[7 + s] = spec[l + s];
            else
                l++;    // illegal character, skip it
        }
    }

    // if not already there, go backwards to '\' (start of filename)
    while (l > 0 && spec[l] != '\\')
        l--;

    if (l > 0)
    {
        s = l + 1;
        for (l++; l < d && l - s < 8; l++)
        {
            if (spec[l] >= 'a' && spec[l] <= 'z')
                rgDrives[iVM][i].name[l - s] = spec[l] - 'a' + 'A';
            else if ((spec[l] >= 'A' && spec[l] <= 'Z') || (spec[l] >= '0' && spec[l] <= '9' && s != l))
                rgDrives[iVM][i].name[l - s] = spec[l];
            else
                s++;    // illegal character, or starts with number, skip it
        }
    }
}

void DeleteDrive(int iVM, int i)
{
    if ((rgDrives[iVM][i].h > 0) && (rgDrives[iVM][i].h != 65535))
        _close(rgDrives[iVM][i].h);

    rgDrives[iVM][i].mode = MD_OFF;
    rgDrives[iVM][i].h    = (WORD)-1;
}

BOOL AddDrive(int iVM, int i, BYTE *pchPath)
{
    int h, sc=0;

    if (pchPath[0] == 'd' || pchPath[0] == 'D')
        {
        if (fXFCable && pchPath[2] == ':')
            {
            rgDrives[iVM][i].mode = MD_EXT;
            return TRUE;
            }
        }

    if ((rgDrives[iVM][i].h > 0) && (rgDrives[iVM][i].h != 65535))
        _close(rgDrives[iVM][i].h);
    rgDrives[iVM][i].h = (WORD)-1;

    h = _open((LPCSTR)pchPath, _O_BINARY | _O_RDWR);

    // do not alter right protect status per disk, let it be remembered for a drive
    //rgDrives[iVM][i].fWP = 1;

    if (h == -1)
    {
        h = _open((LPCSTR)pchPath, _O_BINARY | _O_RDONLY);
        if (h == -1)
            goto Lbadfile;

        rgDrives[iVM][i].fWP = 1;  // file is read-only or in use
    }

    rgDrives[iVM][i].h = (WORD)h;
    rgDrives[iVM][i].wSectorMac = 720;
    rgDrives[iVM][i].mode = MD_SD;
    strcpy(rgDrives[iVM][i].path, (const char *)pchPath);

    if (_read(h,&sc,2) == 2)
    {
        ULONG l;

        l = _lseek(h,0,SEEK_END);
        rgDrives[iVM][i].cb = l;
        _lseek(h,2,SEEK_SET);

        if (sc == 0x296)
        {
            // it's an SIO2PC created image

            rgDrives[iVM][i].ofs = 16;
            _read(h,&l,2);                     // size lo
            _read(h,&sc,2);                     // bytes/sec
            _read(h,(((char *)&l) + 2),2);     // size hi

            l = l << 4;
            rgDrives[iVM][i].wSectorMac = (WORD)(l / sc);

            if (sc == 256)
            {
                char cc[128];

                // Normally, the first three sectors are packed into the first 384 bytes. Then there is 384 blank bytes.
                // Then starts sector 4 at offset $300
                rgDrives[iVM][i].mode = MD_DD;

                // Some old broken .ATR files have the 1st 3 sectors as the first half of the first 3 256 byte sectors
                // 128-256 will be empty only in this version. Also make sure sector 1 is not empty. We want a blank disk
                // to register as a normal DD disk, not this.
                if (_lseek(h, 128 + 16, SEEK_SET) == 128 + 16)
                    if (_read(h, cc, 128) == 128)
                        if (IsEmpty(cc))
                            if (_lseek(h, 16, SEEK_SET) == 16)
                                if (_read(h, cc, 128) == 128)
                                    if (!IsEmpty(cc))
                                        rgDrives[iVM][i].mode = MD_DD_OLD_ATR1;

                // Other old broken .ATR files have sector 4 start right at offset 384 w/o any blank space
                // 384-512 will not be blank only in this version. But if sector 4 is blank, we won't realize it's this kind of file,
                // but we can go by the fact that it's shorter than the other types of files
                if (_lseek(h, 384 + 16, SEEK_SET) == 384 + 16)
                    if (_read(h, cc, 128) == 128)
                        if (!IsEmpty(cc) || l == 0x2ce80)
                        {
                            rgDrives[iVM][i].mode = MD_DD_OLD_ATR2;
                            rgDrives[iVM][i].wSectorMac = 720;  // it looked like 718 before because it's shorter
                        }
            }
        }
        else
        {
            // assume it's a Xformer Cable created image
            // so just check for density
       
            rgDrives[iVM][i].ofs = 0;

            char *path = rgDrives[iVM][i].path;
            int pl = strlen(path);

            if (l == 368640)
            {
                rgDrives[iVM][i].mode = MD_QD;
                rgDrives[iVM][i].wSectorMac = 1440;
            }
            else if (l == 184320)
            {
                rgDrives[iVM][i].mode = MD_DD;
                rgDrives[iVM][i].wSectorMac = 720;
            }
            else if (l == 133120)
            {
                rgDrives[iVM][i].mode = MD_ED;
                rgDrives[iVM][i].wSectorMac = 1040;
            }
            
            // somehow, there are XFD files out there not the right size. We better work with them, that's our format!
            // raw disk images often have a 3 sector loader at first, seeing 0x300 means we're a raw image w/o a header
            // and therefore a good candidate for an XFD file. Also if our extension is XFD.
            else if (l == 92160 || (l < 133120 && sc == 0x300) || (pl >=3 && !_stricmp(&path[pl - 3], "xfd")))
            {
                rgDrives[iVM][i].mode = MD_SD;
                rgDrives[iVM][i].wSectorMac = 720;
            }
            
            else if ((l > 0) && (l <= 368640 /* was 88375 */))
            {
                // it might be a BASIC or EXE file that we fake up as a virtual disk

                if (sc == 0xffff)
                    rgDrives[iVM][i].mode = MD_FILEBIN;     // ATARI binary file
                else if (sc == 0x0000)
                {
                    rgDrives[iVM][i].mode = MD_FILEBAS;     // ATARI BASIC tokenized file (I hope)
                    ramtop = 0xa000;                        // we'll need the basic cartridge
                }
                else
                    rgDrives[iVM][i].mode = MD_FILE;        // who knows?

                // how many 125 byte sectors fit in a file this big, plus 3 boot sectors plus 9 directory sectors + 1 partial
                // !!! BASIC also needs to fit autorun.sys and dos.sys, but is less likely to be super-huge?
                rgDrives[iVM][i].wSectorMac = (WORD)max(720, l / 125 + 13);
                rgDrives[iVM][i].fWP = 1;  // force read-only for fake disks that can't be written to
                rgDrives[iVM][i].cb = l;

                AtariFNFromPath(iVM, i, pchPath);  // make an ATARI compatible filename

#if 0
                // REVIEW: why did I do this?

                while ((pchT = strstr(pch,":")) != NULL)
                    pch = pchT+1;

                while ((pchT = strstr(pch,"\\")) != NULL)
                    pch = pchT+1;
#endif

            }
            else
            {
                // invalid disk image
Lbadfile:
                rgDrives[iVM][i].mode = MD_OFF;
            }
        }
    }
    else
        rgDrives[iVM][i].ofs = 0;

//            _close(h);
    return TRUE;
}

#define NO_TRANSLATION    32
#define LIGHT_TRANSLATION 0
#define HEAVY_TRANSLATION 16


// !!! What is this?
// XL/XE serial I/O handler
//
void BUS1(int iVM)
{
    WORD wRetStat = 1;
    WORD wStat = 0;

    // !!! statics. CIO won't work!
    static BYTE oldstat = 0;
    static BYTE mdTranslation = NO_TRANSLATION;
    static BYTE fConcurrent = FALSE;

//    printf("in bus handler, regPC = %04X\n", regPC);

    switch (regPC & 0x00F0)
    {
    default:
        break;

    case 0x00:    // CIO open
        FSetBaudRate(0, 0, 64, 1);
        break;

    case 0x10:  // CIO close
        fConcurrent = FALSE;
        break;

    case 0x20:  // CIO get byte

#if DEBUGCOM
        printf("g%04X", wStat); fflush(stdout);
#endif

        if (0x0100 & wStat)
            {
            wStat = 0;
            CchSerialRead((char *)&wStat, 1);

#if DEBUGCOM
            printf("G%04X", wStat); fflush(stdout);
#endif
            if (wStat & 0xFF00)
                wRetStat = 136;

            regA = (BYTE)wStat;

            if (mdTranslation != NO_TRANSLATION)
                {
                if (regA == 13)
                    regA = 155;
                else
                    regA &= 0x7F;
                }
            }
        else
            wRetStat = 136;
        break;

    case 0x30:  // CIO put byte
        if (mdTranslation != NO_TRANSLATION)
            {
            if (regA == 155)
                regA = 13;
            else
                regA &= 0x7F;
            }

        FWriteSerialPort(regA);
        break;

    case 0x40:  // CIO status
        if (CchSerialPending())
            wStat = 0x4030;
        else
            wStat = 0x4130;

        if (fConcurrent)
            {
            cpuPokeB (iVM, 746,0);   // error bits
            cpuPokeB (iVM, 748,0);   // unknown
            cpuPokeB (iVM, 749,0);   // characters to be sent

            // do character pending

#if DEBUGCOM
            printf("s%04X", wStat); fflush(stdout);
#endif

            if (0x0100 & wStat)
                cpuPokeB (iVM, 747,1);
            else
                cpuPokeB (iVM, 747,0);
//    printf("%d",cpuPeekB(747)); fflush(stdout);
            }
        else
            {
            // block mode status

            cpuPokeB (iVM, 746,0);   // error bits

            // BIOS returns CD in bit 7, DSR in bit 5, CTS in bit 4
            // Atari needs CD in bit 3, DSR in bit 7, CTS in bit 5

            wStat = ((wStat & 0x80)>>4) | ((wStat & 0x20)<<2) | ((wStat & 0x10)<<1);

            wStat |= oldstat;
            oldstat = (BYTE)(wStat >> 1) & 0x54;

            cpuPokeB (iVM, 747,(BYTE)wStat);   // handshake bits
            }

        break;

    case 0x50:  // CIO special
#if DEBUGCOM
        printf("XIO %d, aux1 = %d, aux2 = %d\n", cpuPeekB(0x22), cpuPeekB(0x2A), cpuPeekB(0x2B));
#endif

        switch (cpuPeekB(iVM, 0x22))
            {
        default:
            break;

        case 32:     // flush output buffer
            break;

        case 34:     // handshake
            break;

        case 36:     // Baud, stop bits, ready monitoring
            {
            int baud = 300;

            switch (cpuPeekB(iVM, 0x2A) & 15)
                {
            default:
                break;

            case 2:    //  50 baud
            case 4:    //  75 baud
            case 5:    // 110 baud
                baud = 110;
                break;

            case 6:    // 134 baud
            case 7:    // 150 baud
                baud = 150;
                break;

            case 9:    // 600 baud
                baud = 600;
                break;

            case 10:   // 1200 baud
                baud = 1200;
                break;

            case 11:    // 1800 baud
            case 12:    // 2400 baud
                baud = 2400;
                break;

            case 13:    // 4800 baud
                baud = 4800;
                break;

            case 14:    // 9600 baud
            case 15:    // 19200 baud
                baud = 9600;
                break;
                }

        FSetBaudRate(0, 0, 19200/baud, 1);

#if DEBUGCOM
            printf("setting baud rate to %d\n", baud);
#endif
            }
            break;

        case 38:     // translation and parity

            mdTranslation = cpuPeekB(iVM, 0x2A) & 48;
#if DEBUGCOM
            printf("mdTranslation set to %d\n", mdTranslation);
#endif
            break;

        case 40:     // set concurrent mode
            fConcurrent = TRUE;
#if DEBUGCOM
            printf("concurrent mode set\n");
#endif
            break;
            }
        break;

    case 0x60:  // init vector
        if ((wCOM != 0) && (wCOM != 1))
            break;

        // !!! WTF? This breaks Sparta Dos SP32D, because this is the external PIA H/W device bank #
        //cpuPokeB (iVM, 583, cpuPeekB(iVM, 247) | 1); // tell OS that device 1 is a CIO device

        cpuPokeB (iVM, 797,'R');
        cpuPokeB (iVM, 798,0x8F);
        cpuPokeB (iVM, 799,0xE4);
        break;

    case 0x70:  // SIO vector   !!! What to do?
        break;

    case 0x80:  // interrupt vector
        break;
    }

    cpuPokeB (iVM, 0x343,(BYTE)wRetStat);
    regY = (BYTE)wRetStat;
    regP = (regP & ~ZBIT) | ((wRetStat & 0x80) ? 0 : ZBIT);
    regP = (regP & ~NBIT) | ((wRetStat & 0x80) ? NBIT : 0);

    regP |= CBIT; // indicate that command completed successfully

    //regPC = cpuPeekW(iVM, regSP + 1) + 1;        // do an RTS
    //regSP = (regSP + 2) & 255 | 256;

    // the stack might wrap!
    regSP = 0x100 | ((regSP + 1) & 0xFF);
    regPC = rgbMem[regSP];
    regSP = 0x100 | ((regSP + 1) & 0xFF);
    regPC |= (WORD)rgbMem[regSP] << 8;
    regPC++;
}


// SIO Bare bones, get some information that's private to this file
//
void SIOGetInfo(int iVM, int drive, BOOL *psd, BOOL *ped, BOOL *pdd, BOOL *pfwp)
{
    WORD md = rgDrives[iVM][drive].mode;

    if (psd)
        *psd = (rgDrives[iVM][drive].mode == MD_SD);
    if (ped)
        *ped = (rgDrives[iVM][drive].mode == MD_ED);
    if (pdd)
        *pdd = (md == MD_QD) || (md == MD_DD) || (md == MD_DD_OLD_ATR1) || (md == MD_DD_OLD_ATR2) || (md == MD_HD) || (md == MD_RD);
    if (pfwp)
        *pfwp = rgDrives[iVM][drive].fWP;
}


// SIO Bare bones read a sector, return checksum for those rolling their own and not using SIOV
//
BYTE SIOReadSector(int iVM, int wDrive)
{
    WORD wDev, wCom, wStat, wSector;
    WORD  wBytes;
    WORD wTimeout;
    WORD md;
    DRIVE *pdrive;
    ULONG lcbSector;

    wDev = (WORD)(wDrive + 0x31);
    wCom = 0x52;
    wStat = 0x40;
    wTimeout = 0x1f;
    wBytes = 128;
    wSector = rgSIO[2] | (WORD)rgSIO[3] << 8;

    pdrive = &rgDrives[iVM][wDrive];

    md = pdrive->mode;

    // At least for Eidolon V1, just treating DD disks as SD seems to work!
    // !!! How does non-SD work?
    if (md != MD_SD)
    {
//        ODS("Bare bones SIO not supported on DD Drive?\n");
//        return 0;
    }

    if (pdrive->h == -1)
        return 0;

    int cbSIO2PCFudge = pdrive->ofs;

    if (wSector < 1)            /* invalid sector # */
        return 0;

    if (wSector > pdrive->wSectorMac)   /* invalid sector # */
        return 0;

    lcbSector = 128L;

    _lseek(pdrive->h, (ULONG)((wSector - 1) * lcbSector) + cbSIO2PCFudge, SEEK_SET);

    if (_read(pdrive->h, sectorSIO[iVM], wBytes) < wBytes)
        return 0;

    /* the disk # is valid, the sector # is valid, # bytes is valid */

    // now do the checksum
    WORD ck = 0;
    for (int i = 0; i < 128; i++)
    {
        ck += sectorSIO[iVM][i];
        if (ck > 0xff)
        {
            ck = ck & 0xff;
            ck++;    // add carry back in after every addition
        }
    }
    ck = ck & 0xff;
    return (BYTE)ck;
}


// ATARI 800 serial I/O handler
//
void SIOV(int iVM)
{
    WORD wDev, wDrive, wCom, wStat, wBuff, wSector, bAux1, bAux2;
    WORD  wBytes;
    WORD wTimeout;
    WORD fDD;
    WORD wRetStat = SIO_OK;
    WORD md;
    DRIVE *pdrive;
    ULONG lcbSector;
    BYTE rgb[256];
    WORD i;

    // we're the 800 SIO routine. Otherwise, BUS1 is the XL/XE version
    if (regPC != 0xE459 && regPC != 0xE959)
    {
        BUS1(iVM);
        return;
    }

#if 0
    printf("Device ID = %2x\n", cpuPeekB(0x300));
    printf("Drive # = %2x\n", cpuPeekB(0x301));
    printf("Command = %2x\n", cpuPeekB(0x302));
    printf("SIO Command = %2x\n", cpuPeekB(0x303));
    printf("Buffer = %2x\n", cpuPeekW(0x304));
    printf("Timeout = %2x\n", cpuPeekW(0x306));
    printf("Byte count = %2x\n", cpuPeekW(0x308));
    printf("Sector = %2x\n", cpuPeekW(0x30A));
    printf("Aux1 = %2x\n", cpuPeekB(0x30A));
    printf("Aux2 = %2x\n", cpuPeekB(0x30B));
#endif

    wDev = cpuPeekB(iVM, 0x300);
    wDrive = cpuPeekB(iVM, 0x301)-1;
    wCom = cpuPeekB(iVM, 0x302);
    wStat = cpuPeekB(iVM, 0x303);
    wBuff = cpuPeekW(iVM, 0x304);
    wTimeout = cpuPeekW(iVM, 0x306);
    wBytes = cpuPeekW(iVM, 0x308);
    wSector = cpuPeekW(iVM, 0x30A);
    bAux1 = cpuPeekB(iVM, 0x30A);
    bAux2 = cpuPeekB(iVM, 0x30B);

#if 0
    if (wCom == 0x52)
        ODS("SIOV: Read SECTOR %d into %04x\n", wSector, wBuff);
    else
        ODS("SIOV: Command %02x\n", wCom);
#endif

    if (wDev == 0x31)       /* disk drives */
    {
#if 0
        // SIO is supposed to copy the drive and aux bytes of the last command into CDEVIC (Alternate Reality - Dungeon)
        rgbMem[0x23a] = wDev + wDrive;
        rgbMem[0x23b] = wCom;
        rgbMem[0x23c] = bAux1;
        rgbMem[0x23d] = bAux2;
#endif

        if ((wDrive < 0) || (wDrive >= MAX_DRIVES))
            goto lCable;

        pdrive = &rgDrives[iVM][wDrive];

        md = pdrive->mode;

        if (md == MD_OFF)           /* drive is off */
            {
            wRetStat = 138;
            goto lExit;
            }

        if (md == MD_EXT)
            goto lCable;

        if (md == MD_35)            /* 3.5" 720K disk */
            {
lNAK:
            wRetStat = SIO_NAK;
            goto lExit;
            }

        fDD = (md==MD_QD) || (md==MD_DD) || (md==MD_DD_OLD_ATR1) || (md==MD_DD_OLD_ATR2) || (md==MD_HD) || (md==MD_RD);

        if (pdrive->h == -1)
            goto lNAK;

        /* the disk # is valid, the sector # is valid, # bytes is valid */

        switch(wCom)
        {
        default:
         /*   printf("SIO command %c\n", wCom); */
            wRetStat = SIO_NAK;
            break;

        /* format enhanced density, we don't support that */
        case '"':
            if (md != MD_ED)
                wRetStat = SIO_NAK;
            break;

        case '!':
            if (pdrive->fWP)       /* is drive write-protected? */
                {
                wRetStat = SIO_DEVDONE;
                break;
                }

            /* "format" disk, just zero all sectors */

            memset(rgb,0,sizeof(rgb));

            if ((md == MD_SD) || (md == MD_ED))
                lcbSector = 128L;
            else
                lcbSector = 256L;

            _lseek(pdrive->h,(ULONG)pdrive->ofs,SEEK_SET);

            for (i = 0; i < pdrive->wSectorMac; i++)
                {
                if (_write(pdrive->h,(void *)&rgb,(WORD)lcbSector) < (WORD)lcbSector)
                    {
                    wRetStat = SIO_DEVDONE;
                    break;
                    }
                }
            break;

        /* status request */
        case 'S':
          /*  printf("SIO command 'S'\n"); */

            /* b7 = enhanced   b5 = DD/SD  b4 = motor on   b3 = write prot */
            cpuPokeB (iVM, wBuff++, ((md == MD_ED) ? 128 : 0) + (fDD ? 32 : 0) + (pdrive->fWP ? 8 : 0));

            cpuPokeB (iVM, wBuff++, 0xFF);         /* controller */
            cpuPokeB (iVM, wBuff++, 0xE0);         /* format timeout */
            cpuPokeB (iVM, wBuff, 0x00);           /* unused */
            break;

        /* get configuration */
        case 'N':
          /*  printf("SIO command 'N'\n"); */
            if (md == MD_HD)
                {
                pdrive->wSectorMac--;
                cpuPokeB (iVM, wBuff++, 1);   /* tracks */
                cpuPokeB (iVM, wBuff++, 0);    /* ?? */
                cpuPokeB (iVM, wBuff++, pdrive->wSectorMac & 255);   /* ?? */
                cpuPokeB (iVM, wBuff++, pdrive->wSectorMac >> 8);    /* sectors/track */
                cpuPokeB (iVM, wBuff++, 0x00);         /* ?? */
                pdrive->wSectorMac++;
                }
            else
                {
                cpuPokeB (iVM, wBuff++, 0x28);         /* tracks */
                cpuPokeB (iVM, wBuff++, 0x02);         /* ?? */
                cpuPokeB (iVM, wBuff++, 0x00);         /* ?? */
                cpuPokeB (iVM, wBuff++, (md == MD_ED) ? 0x1A : 0x12); /* secs/track */
                cpuPokeB (iVM, wBuff++, 0x00);         /* ?? */
                }

            if (fDD)
                {
                cpuPokeB (iVM, wBuff++, 0x04);     /* density: 4 = dbl  0 = sng */
                cpuPokeB (iVM, wBuff++, 0x01);     /* bytes/sector hi */
                cpuPokeB (iVM, wBuff++, 0x00);     /* bytes/sector lo */
                }
            else
                {
                cpuPokeB (iVM, wBuff++, 0x00);     /* density: 4 = dbl  0 = sng */
                cpuPokeB (iVM, wBuff++, 0x00);     /* bytes/sector hi */
                cpuPokeB (iVM, wBuff++, 0x80);     /* bytes/sector lo */
                }
            cpuPokeB (iVM, wBuff++, 0xFF);         /* unused */
            cpuPokeB (iVM, wBuff++, 0xFF);         /* unused */
            cpuPokeB (iVM, wBuff++, 0xFF);         /* unused */
            cpuPokeB (iVM, wBuff, 0xFF);           /* unused */
            break;

        /* set configuration - we don't support it */
        case 'O':
          /*  printf("SIO command 'O'\n"); */
            wRetStat = SIO_OK;
            break;
            goto lNAK;

        case 'P':
        case 'W':
        case 'R':
            {
            int cbSIO2PCFudge = pdrive->ofs;

            if (wSector < 1)            /* invalid sector # */
                goto lNAK;

            if ((wSector < 4) || (md == MD_FILE) || (md == MD_FILEBIN) || (md == MD_FILEBAS) || (md == MD_SD) || (md == MD_ED))
                {
                if (wBytes != 128)
                    goto lNAK;
                }
            else if (md == MD_HD)
                wBytes = 256;
            else if (wBytes != 256)
                goto lNAK;

            if (wSector > pdrive->wSectorMac)   /* invalid sector # */
                goto lNAK;

            if ((md == MD_FILE) || (md == MD_FILEBIN) || (md == MD_FILEBAS) || (md == MD_SD) || (md == MD_ED))
                lcbSector = 128L;
            else if ((wSector < 4) && pdrive->ofs)  // SIO2PC disk image
            {
                lcbSector = 128L;
                // the data is in the first half of a 256 byte sector
                if (md == MD_DD_OLD_ATR1)
                    lcbSector = 256;
            }
            else if (pdrive->ofs)
                {
                lcbSector = 256L;
                if (pdrive->cb == 184720)    // !!! 400 byte header instead of 16, what is this?
                    cbSIO2PCFudge += 384;

                // the first 3 sectors were compacted
                else if (md == MD_DD_OLD_ATR2)
                {
                    wSector -= 1;
                    cbSIO2PCFudge -= 128;
                }
            }
            else
                lcbSector = 256L;

            // !!! Arena is mean and uses a custom SEROUT needed interrupt with SIOV to change the sector # to load
            // after SIOV is called from a certain point on
            if (wLastSIOSector == 9 && wSector == 9 && rgbMem[0xbb8a] == 0x3c)
            {
                wSector = 10;           // start the hack
                wLastSIOSector = -1;
            }
            else if (wLastSIOSector == -1)
            {
                if (wSector > 9)
                    wSector++;
                else
                    wLastSIOSector = 0; // stop the hack
            }

            _lseek(pdrive->h,(ULONG)((wSector-1) * lcbSector) + cbSIO2PCFudge,SEEK_SET);

            if ((wCom == 'R'))    // wStat is only checked for cassette I/O not disk I/O, breaks apps // && (wStat == 0x40))
            {
#if 0
                printf("Read: sector = %d  wBuff = $%4x  wBytes = %d  lcbSector = %ld  md = %d\n",
                    wSector, wBuff, wBytes, lcbSector, md);
#endif
                // now that SIO is not instantaneous, mute the audio so it doesn't hold a high pitch (MULE).
                // Since I/O makes sounds, I presume it's OK to alter the sounds on the user like this
                //AUDF1 = AUDF2 = AUDF3 = AUDF4 = 0;    // doesn't work by itself!
                AUDC1 = AUDC2 = AUDC3 = AUDC4 = 0;
                
                // do not read into ROM and overwrite something we shouldn't. If the OS is swapped out, himem could be RAM.
                // Maybe I should make a flag to save me this trouble.
                BYTE temp = rgbMem[wBuff];
                BYTE temp2 = rgbMem[wBuff + wBytes - 1];
                PokeBAtari(iVM, wBuff, temp + 1);   // this will disallow an attempted write to ROM
                PokeBAtari(iVM, wBuff + wBytes - 1, temp2 + 1);

                // !!! this test fails to write any bytes if the buffer straddles ROM, we err on the side of not hurting ROM.
                // Our binary loader hacks (MD_FILEBIN) actually might load into ROM ($d600 hack)
                if (rgbMem[wBuff] == temp || rgbMem[wBuff + wBytes - 1] == temp2)
                    wRetStat = SIO_OK;
                else if ((md == MD_FILE) || (md == MD_FILEBIN) || (md == MD_FILEBAS))
                {
                    // read a normal file as an 8-bit file in a virtual disk

                    memset(rgb, 0, sizeof(rgb));
                    _fmemset(&rgbMem[wBuff], 0, 128);

                    if (wSector == 360)
                    {
                        // FAT sector

                        // subtract size of our file to get free space
                        BYTE bl = (BYTE)((pdrive->cb + 124L) / 125L);
                        BYTE bh = (BYTE)((pdrive->cb + 124L) / 32000L);
                        WORD wUsed = (bh << 8) | bl;
                        if (md == MD_FILEBAS)
                            wUsed += (39 + 2);  // add DOS.SYS and AUTORUN.SYS sizes too
                        WORD wUnused = (WORD)(707 - wUsed);

                        rgbMem[wBuff + 0] = 0x02;       // VTOC
                        rgbMem[wBuff + 1] = 0xC3;
                        rgbMem[wBuff + 2] = 0x02;       // # of sectors on disk
                        rgbMem[wBuff + 3] = wUnused & 0xff;
                        rgbMem[wBuff + 4] = wUnused >> 8;     // # of free sectors

                        _fmemset(&rgbMem[wBuff + 10], 0xff, 90);   // 1 = unused sector (90 * 8 = 720)
                        rgbMem[wBuff + 10] = (BYTE)~0x70;   // mark first 3 sectors used
                        rgbMem[wBuff + 10 + 45] = 0;        // mark VTOC etc used
                        rgbMem[wBuff + 10 + 46] = 0x7f;        // mark VTOC etc used

                        // mark all the right sectors as used
                        for (int ss = 0; ss < wUsed; ss++)
                        {
                            int sec = ss + 4;   // file starts at sector 4
                            if (sec >= 360)     // file skips sectors 360-368
                                sec += 9;
                            if (sec > 719)
                                sec = 719;      // max. possible DOS sector

                            int s1 = sec & 7;
                            int s2 = sec >> 3;
                            
                            rgbMem[wBuff + 10 + s2] &= ~(0x80 >> s1);   // mark sector used (0)
                        }
                    }
                    else if (wSector == 361)
                    {
                        // directory sector
                        
                        int s1 = 0;

                        // 1st file is DOS.SYS in a BASIC image
                        if (md == MD_FILEBAS)
                        {
                            rgbMem[wBuff + 0] = 0x42;
                            rgbMem[wBuff + 1] = 39;     // length
                            rgbMem[wBuff + 2] = 0;
                            rgbMem[wBuff + 3] = 0x04;   // start sector
                            rgbMem[wBuff + 4] = 0x00;
                            memcpy(&rgbMem[wBuff + 5], "DOS     SYS", 11);

                            rgbMem[wBuff + 16] = 0x42;
                            rgbMem[wBuff + 17] = 2;     // length
                            rgbMem[wBuff + 18] = 0;
                            rgbMem[wBuff + 19] = 43;    // start sector
                            rgbMem[wBuff + 20] = 0x00;
                            memcpy(&rgbMem[wBuff + 21], "AUTORUN SYS", 11);
                            s1 = 32;
                        }
                        rgbMem[wBuff + s1 + 0] = 0x42;
                        rgbMem[wBuff + s1 + 1] = (BYTE)((pdrive->cb + 124L) / 125L);    // length
                        rgbMem[wBuff + s1 + 2] = (BYTE)((pdrive->cb + 124L) / 32000L);
                        rgbMem[wBuff + s1 + 3] = (md == MD_FILEBAS) ? 45 : 4;   // starts at 45 if DOS.SYS and AUTORUN.SYS present
                        rgbMem[wBuff + s1 + 4] = 0x00;
                        memcpy(&rgbMem[wBuff + s1 + 5], pdrive->name, 11);
                    }
                    else if (wSector >= 4)
                    {
                        // data sector

                        int s1 = 4;

                        if (md == MD_FILEBAS)
                        {
                            memcpy(&rgbMem[wBuff], &DOS20[(ULONG)((wSector - s1) * 125L)], 125);

                            // sector 1 of AUTORUN.SYS
                            if (wSector == 43)
                            {
                                memcpy(&rgbMem[wBuff], &AUTORUN[0], 125);
                                
                                rgbMem[wBuff + 125] = (BYTE)((wSector + 1) >> 8) | 4;   // 4 for file #1
                                rgbMem[wBuff + 126] = (BYTE)(wSector + 1);
                                rgbMem[wBuff + 127] = 125;
                            }
                            // sector 2 of AUTORUN.SYS
                            else if (wSector == 44)
                            {
                                int s2;
                                for (s2 = 0; s2 < 8 && pdrive->name[s2] != ' '; s2++)
                                    AUTORUN[141 - s2] = pdrive->name[s2]; // filename to auto-run appears backwards
                                AUTORUN[141 - s2] = 0x2e;
                                AUTORUN[141 - s2 - 1] = pdrive->name[8];
                                AUTORUN[141 - s2 - 2] = pdrive->name[9];
                                AUTORUN[141 - s2 - 3] = pdrive->name[10];

                                memcpy(&rgbMem[wBuff], &AUTORUN[125], 31);
                                
                                rgbMem[wBuff + 125] = 0 | 4;    // 4 for file #1
                                rgbMem[wBuff + 126] = 0;
                                rgbMem[wBuff + 127] = 31;
                            }
                            else if (wSector == 42)
                            {
                                memcpy(&rgbMem[wBuff], &DOS20[(ULONG)((wSector - s1) * 125L)], 125);
                                rgbMem[wBuff + 125] = 0x00;
                                rgbMem[wBuff + 126] = 0x00;
                                rgbMem[wBuff + 127] = 125;
                            }
                            else if (wSector < 42)
                            {
                                memcpy(&rgbMem[wBuff], &DOS20[(ULONG)((wSector - s1) * 125L)], 125);
                                rgbMem[wBuff + 125] = (BYTE)((wSector + 1) >> 8);
                                rgbMem[wBuff + 126] = (BYTE)(wSector + 1);
                                rgbMem[wBuff + 127] = 125;
                            }
                            
                            s1 = 45;
                        }

                        if (wSector > 368)   // skip FAT/directory sectors
                            wSector -= 9;

                        if (wSector >= s1)
                        {
                            _lseek(pdrive->h, (ULONG)((wSector - s1) * 125L), SEEK_SET);

                            if ((rgbMem[wBuff + 127] = (BYTE)_read(pdrive->h, &rgbMem[wBuff], 125)) < 125)
                            {
                                rgbMem[wBuff + 125] = 0x00 | (md == MD_FILEBAS ? 8 : 0);    // FILE # 0 (BIN) or 2 (BAS) in bits 7-2
                                rgbMem[wBuff + 126] = 0x00;
                            }
                            else
                            {
                                wSector++;

                                if (wSector >= 360)
                                    wSector += 9;

                                // !!! DOS only allows 2 high bits for sector number, and large XEX files fill >1024 sectors
                                // Squeeze the full sector # in there anyway, and our loader will handle it but it won't be
                                // a completely valid DOS image, but who cares
                                rgbMem[wBuff + 125] = (BYTE)(wSector >> 8) | (md == MD_FILEBAS ? 8 : 0);    // FILE # 0 or 2 in bits 7-2
                                rgbMem[wBuff + 126] = (BYTE)wSector;
                            }
                        }
                    }
                    // sector 1-3, provide boot disk data for binary and BASIC files to be auto-loaded
                    else
                    {
                        if (md == MD_FILEBIN)
                        {
                            if (wSector == 1)
                            {
                                // which of the 2 load routines do we want for this binary?
                                if (fAltBinLoader)
                                    memcpy(&rgbMem[wBuff], BinA1, 128);
                                else
                                    memcpy(&rgbMem[wBuff], Bin1, 128);
                            }
                            else if (wSector == 2)
                            {
                                if (fAltBinLoader)
                                    memcpy(&rgbMem[wBuff], BinA2, 128);
                                else
                                    memcpy(&rgbMem[wBuff], Bin2, 128);
                            }
                            else
                            {
                                if (fAltBinLoader)
                                    memcpy(&rgbMem[wBuff], BinA3, 128);
                                else
                                    memcpy(&rgbMem[wBuff], Bin3, 128);
                            }
                        }
                        else if (md == MD_FILEBAS)
                        {
                            if (wSector == 1)
                                memcpy(&rgbMem[wBuff], Bas1, 128);
                            else if (wSector == 2)
                                memcpy(&rgbMem[wBuff], Bas2, 128);
                            else
                                memcpy(&rgbMem[wBuff], Bas3, 128);
                        }
                    }
                }
                else if (_read(pdrive->h, &rgbMem[wBuff], wBytes) < wBytes)
                    wRetStat = SIO_DEVDONE;
                else
                {
                    // now pretend 7 jiffies elapsed for apps that time disk sector reads (Repton)
                    BYTE jif = 7;
                    // reading the same sector as last time takes twice as long
                    if (wSector == wLastSIOSector)
                        jif = 14;
                    BYTE oldjif = rgbMem[20];
                    rgbMem[20] = oldjif + jif;
                    if (oldjif >= (256 - jif))
                    {
                        oldjif = rgbMem[19];
                        rgbMem[19]++;
                        if (oldjif == 255)
                            rgbMem[18]++;
                    }

                    wRetStat = SIO_OK;
                    if (wLastSIOSector >= 0)
                        wLastSIOSector = wSector;
                }
            }
            else if ((wCom == 'W') || (wCom == 'P'))
                {
                //if (wStat != 0x80)    // only the cassette handler checks this, not disk I/O, this would break apps
                //    goto lNAK;
                if (pdrive->fWP)
                    {
                    wRetStat = SIO_DEVDONE;
                    break;
                    }
                if (_write(pdrive->h, (LPCCH)&rgbMem[wBuff],wBytes) < wBytes)
                    wRetStat = SIO_DEVDONE;
                else
                    wRetStat = SIO_OK;
                }
            break;
            }
        }
    }

    else if (!fXFCable && wDev == 0x40)      /* printer */
        {
        int timeout = 32000;

#ifdef xDEBUG
        printf("printer SIO: wDev = %2x  wCom = %2x  wBytes = %2x\n",
            wDev, wCom, wBytes);
        printf("SIO: wBuff = %4x  bAux1 = %2x  bAux2 = %2x\n",
            wBuff, bAux1, bAux2);
#endif

        switch(wCom)
            {
        /* status request */
        case 'S':
            while (timeout--)
                {
                if (FPrinterReady(iVM))
                    {
                    wRetStat = SIO_OK;
                    break;
                    }

                if (timeout == 0)
                    {
                    wRetStat = SIO_TIMEOUT;
                    break;
                    }
                }
            break;

        case 'W':
            /* print line */
            {
            BYTE *pchBuf = &rgbMem[wBuff];
            int  cch = wBytes;
            BYTE ch;

            while ((pchBuf[cch-1] == ' ') && (cch>0))
                cch--;

            while ((cch-- > 0) && (wRetStat == SIO_OK))
                {
                ch = *pchBuf++;
#if 0
                printf("printing: %02X\n", ch);
                fflush(stdout);
#endif

                while (timeout--)
                    {
                    if (FPrinterReady(iVM))
                        {
                        if (ch != 155)
                            ByteToPrinter(iVM, ch);
                        else
                            {
                            ByteToPrinter(iVM, 13);
                            ByteToPrinter(iVM, 10);
                            }

                        wRetStat = SIO_OK;
                        break;
                        }

                    if (timeout == 0)
                        {
                        wRetStat = SIO_TIMEOUT;  // else status = timeout error
                        break;
                        }
                    }
                } // while
            }
            } // switch
        }

    else
        {
lCable:
            {
            wRetStat = SIO_TIMEOUT;
            goto lExit;
            }

        ;
        }

#ifdef xDEBUG
    printf("wRetStat = %d\n", wRetStat);
#endif

lExit:
    //ODS("SIOV %02x into %04x aux %04x returns %02x\n", wCom, wBuff, wSector, wRetStat);
    cpuPokeB (iVM, 0x303,(BYTE)wRetStat);
    regY = (BYTE)wRetStat;
    regP = (regP & ~ZBIT) | ((wRetStat == 0) ? ZBIT : 0);
    regP = (regP & ~NBIT) | ((wRetStat & 0x80) ? NBIT : 0);

    rgbMem[0x42] = 0;   // SIO turns CRITIC off so entire VBI can run next time (Shamus loaded from Preppie II disk needs this)

    //regPC = cpuPeekW(iVM, regSP + 1) + 1;        // do an RTS
    //regSP = (regSP + 2) & 255 | 256;

    // the stack might wrap!
    regSP = 0x100 | ((regSP + 1) & 0xFF);
    regPC = rgbMem[regSP];
    regSP = 0x100 | ((regSP + 1) & 0xFF);
    regPC |= (WORD)rgbMem[regSP] << 8;
    regPC++;

    //printf("SIO: returning to PC = %04X, SP = %03X, stat = %02X\n", regPC, regSP, regY);
}

#endif // XFORMER


#if 0
void InitSIOV(int iVM, int argc, char **argv)
{
    int i, iArgv = 0;

#ifdef HDOS16ORDOS32
    _bios_printer(_PRINTER_INIT, 0, 0);
#endif

    wCOM = -1;

    while ((argv[iArgv][0] == '-') || (argv[iArgv][0] == '/'))
    {
        switch (argv[iArgv][1])
        {
        case 'A':
        case 'a':
            fAutoStart = 1;
            break;

        case 'D':
        case 'd':
            fDebugger = 1;
            break;

        case 'N':
        case 'n':
            ramtop = 0xC000;
            break;

        case '8':
            mdXLXE = md800;
            break;

        case 'S':
        case 's':
#ifndef NDEBUG
            printf("sound activated\n");
#endif
            fSoundOn = TRUE;
#ifndef HWIN32
            InitSoundBlaster();
#endif
            break;

        case 'T':
        case 't':
            *pbshift &= ~wScrlLock;
            break;

        case 'C':
        case 'c':
            wCOM = argv[iArgv][2] - '1';
#ifndef NDEBUG
            printf("setting modem to COM%d:\n", wCOM + 1);
#endif
            break;

#ifndef HWIN32
        case 'X':
        case 'x':
            fXFCable = 1;
            if (argv[iArgv][2] == ':')
            {
                _SIO_Init();
                sscanf(&argv[iArgv][3], "%d", &uBaudClock);
            }
            else
            {
                _SIO_Calibrate();
            }
            if (uBaudClock == 0)
            {
                fXFCable = 0;
            }
            else
            {
            }
            break;
#endif // !HWIN32

        case 'K':
        case 'k':
            if (argv[iArgv][2] == ':')
                ReadCart(iVM, &argv[iArgv][3]);
            break;

#ifndef HWIN32
        case 'J':
        case 'j':
#ifndef NDEBUG
            printf("joystick activated\n");
#endif
            MyReadJoy();

            if ((wJoy0X || wJoy1X))
            {
                fJoy = TRUE;

                wJoy0XCal = wJoy0X;
                wJoy0YCal = wJoy0Y;
                wJoy1XCal = wJoy1X;
                wJoy1YCal = wJoy1Y;
            }

#if 0
            for (;;)
            {
                MyReadJoy();
                printf("0X: %04X  0Y: %04X  1X: %04X  1Y: %04X  BUT: %02X\n",
                    wJoy0X, wJoy0Y, wJoy1X, wJoy1Y, bJoyBut);
            }
#endif

            break;
#endif // !HWIN32
        };

        iArgv++;
    }

    for (i = 0; i < MAX_DRIVES; i++)
    {
        if (i < argc)
        {
            AddDrive(iVM, i, argv[i + iArgv]);
        }
        else
            rgDrives[iVM][i].mode = MD_OFF;
    }
}
#endif
